> 编者： 
> 
>     SZTU悍匠平步电控
> 
> ![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\2.Publish_InvertedPendulum_VMC&LQR.jpg)
> 
> 整体思路：
> 
>     通过“由vmc正解算计算出的腿长$L_0$”与“由lqr计算出的K”计算出关轮毂和关节力矩$\begin{bmatrix}T\\T_p \end{bmatrix}$
> 
>     再通过vmc正动力学变换计算出前后关节力矩$\begin{bmatrix} T_1\\T_4 \end{bmatrix}$
> 
> 目录：
> 
> |
> 
> —— 五连杆 VMC
> 
>             |
> 
>             —— Clion代码
> 
>             —— 定义<u></u>
> 
>             —— 正解算
> 
>             —— 正动力学变换
> 
> |
> 
> —— LQR 控制系统
> 
>             |
> 
>             —— Clion代码
> 
>             —— Matlab代码
> 
>             —— 定义
> 
>             —— 计算$A,B$
> 
>             —— 计算$K$
> 
>             —— 计算$u$
> 
>             —— 计算力矩$\begin{bmatrix}T\\T_p \end{bmatrix}$
> 
> |
> 
> ——参考文章
> 
> <mark>套用只需按实际情况改变高亮部分数据</mark>

# 五连杆 VMC

## Clion代码

```robot_def.c
/* =========================== 1.1 机械量 =========================== */

        ChassisPhysicalConfig chassis_physical_config =
        {
                .wheel_radius = 0.06f, // 轮毂半径
                .wheel_weight = 0.167f, // 轮毂质量
                .body_weight = 11.255f, // 纯底盘
                // .body_weight = 11.255f +2.494f, // 加云台
                .l1 = 0.1785f,
                .l2 = 0.2125f,
                .l3 = 0.2125f,
                .l4 = 0.1785f,
                .l5 = 0.0f,
        };
```

```vmc.c
/ ========================= 1.2 phi1 phi4 phi1',phi4'========================= */

    void vmc_phi_update(Leg *leg_L, Leg *leg_R)
    {

        /* ========================= 1.2.1 初始phi1 phi4 ========================= */

            float LF_joint_pos = (get_joint_motors() + 0)->pos_r;
            float LB_joint_pos = (get_joint_motors() + 1)->pos_r;
            float RF_joint_pos = (get_joint_motors() + 2)->pos_r;
            float RB_joint_pos = (get_joint_motors() + 3)->pos_r;

        /* ========================= 1.2.2 实际phi1 phi4 ========================= */

            /* 关节电机零点设置在下限位处，当各电机处于零点处时，机体在腿长最短位置平衡，phi1为π，phi4为0（弧度制）*/

            leg_L->vmc.forward_kinematics.fk_phi.phi1 = LF_joint_pos + PHI1_OFFSET;
            leg_L->vmc.forward_kinematics.fk_phi.phi4 = LB_joint_pos + PHI4_OFFSET;
            leg_R->vmc.forward_kinematics.fk_phi.phi1 = -RF_joint_pos + PHI1_OFFSET;
            leg_R->vmc.forward_kinematics.fk_phi.phi4 = -RB_joint_pos + PHI4_OFFSET;

        /* ========================= 1.2.1 初始phi1‘ phi4’ ========================= */

            float LF_joint_speed = (get_joint_motors() + 0)->angular_vel;
            float LB_joint_speed = (get_joint_motors() + 1)->angular_vel;
            float RF_joint_speed = (get_joint_motors() + 2)->angular_vel;
            float RB_joint_speed = (get_joint_motors() + 3)->angular_vel;

        /* ========================= 1.2.2 实际phi1’ phi4‘ ========================= */

            leg_L->vmc.forward_kinematics.fk_phi.phi1_dot = LF_joint_speed;
            leg_L->vmc.forward_kinematics.fk_phi.phi4_dot = LB_joint_speed;
            leg_R->vmc.forward_kinematics.fk_phi.phi1_dot = -RF_joint_speed;
            leg_R->vmc.forward_kinematics.fk_phi.phi4_dot = -RB_joint_speed;

    }

/* =========================== 1.3-1.6 正解算 =========================== */

    static void forward_kinematics(Leg *leg, ChassisPhysicalConfig *physical_config)
    {

        /* =========================== 中间变量 =========================== */

            float temp=0,temp_y=0,temp_x=0;

        /* =========================== 1.3  B,D坐标 =========================== */

            leg->vmc.forward_kinematics.fk_point_coordinates.b_x = physical_config->l1 * cosf(leg->vmc.forward_kinematics.fk_phi.phi1);
            leg->vmc.forward_kinematics.fk_point_coordinates.b_y = physical_config->l1 * sinf(leg->vmc.forward_kinematics.fk_phi.phi1);
            leg->vmc.forward_kinematics.fk_point_coordinates.d_x = physical_config->l5 + physical_config->l4 * cosf(leg->vmc.forward_kinematics.fk_phi.phi4);
            leg->vmc.forward_kinematics.fk_point_coordinates.d_y = physical_config->l4 * sinf(leg->vmc.forward_kinematics.fk_phi.phi4);

        /* =========================== 1.4  lBD^2  =========================== */

            float L_BD_sq =
                (leg->vmc.forward_kinematics.fk_point_coordinates.d_x - leg->vmc.forward_kinematics.fk_point_coordinates.b_x)
                * (leg->vmc.forward_kinematics.fk_point_coordinates.d_x - leg->vmc.forward_kinematics.fk_point_coordinates.b_x)
                + (leg->vmc.forward_kinematics.fk_point_coordinates.d_y - leg->vmc.forward_kinematics.fk_point_coordinates.b_y)
                * (leg->vmc.forward_kinematics.fk_point_coordinates.d_y - leg->vmc.forward_kinematics.fk_point_coordinates.b_y);

        /* =========================== 1.5  phi2 =========================== */

            float L_A0 =
                2.0f * physical_config->l2
                * (leg->vmc.forward_kinematics.fk_point_coordinates.d_x
                - leg->vmc.forward_kinematics.fk_point_coordinates.b_x);
            float L_B0 =
                2.0f * physical_config->l2
                * (leg->vmc.forward_kinematics.fk_point_coordinates.d_y
                - leg->vmc.forward_kinematics.fk_point_coordinates.b_y);
            float L_C0 =
                physical_config->l2 * physical_config->l2
                + L_BD_sq
                - physical_config->l3 * physical_config->l3;
            temp = L_A0 * L_A0 + L_B0 * L_B0 - L_C0 * L_C0;
            temp_y = L_B0 + sqrtf(ABS(temp));
            temp_x = L_A0 + L_C0;
            leg->vmc.forward_kinematics.fk_phi.phi2 = 2.0f * atan2f(temp_y, temp_x);

        /* =========================== 1.6  xC,yC =========================== */

            leg->vmc.forward_kinematics.fk_point_coordinates.c_x =
                physical_config->l1 * cosf(leg->vmc.forward_kinematics.fk_phi.phi1)
                + physical_config->l2 * cosf(leg->vmc.forward_kinematics.fk_phi.phi2);
            leg->vmc.forward_kinematics.fk_point_coordinates.c_y =
                physical_config->l1 * sinf(leg->vmc.forward_kinematics.fk_phi.phi1)
                + physical_config->l2 * sinf(leg->vmc.forward_kinematics.fk_phi.phi2);

        /* =========================== 1.7 phi3 =========================== */

            temp_y =
                leg->vmc.forward_kinematics.fk_point_coordinates.c_y
                - leg->vmc.forward_kinematics.fk_point_coordinates.d_y;
            temp_x =
                leg->vmc.forward_kinematics.fk_point_coordinates.c_x
                - leg->vmc.forward_kinematics.fk_point_coordinates.d_x;
            leg->vmc.forward_kinematics.fk_phi.phi3 = atan2f(temp_y, temp_x);

        /* =========================== 1.8  L0 =========================== */

            temp =
                (leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f)
                * (leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f)
                + leg->vmc.forward_kinematics.fk_point_coordinates.c_y
                * leg->vmc.forward_kinematics.fk_point_coordinates.c_y;
            leg->vmc.forward_kinematics.fk_L0.L0 = sqrtf(ABS(temp));

        /* =========================== 1.8  phi0 =========================== */

            temp_y = leg->vmc.forward_kinematics.fk_point_coordinates.c_y;
            temp_x = leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f;
            leg->vmc.forward_kinematics.fk_phi.phi0 = atan2f(temp_y, temp_x);
}

/* =========================== 1. 正解算 =========================== */

    void vmc_calc(void)
    {

        /* ========================= 1.2 phi1 phi4 phi1',phi4'========================= */

            vmc_phi_update(&chassis.leg_L, &chassis.leg_R);

        /* =========================== 1.3-1.6 正解算 =========================== */

            forward_kinematics(&chassis.leg_L, &chassis_physical_config);
            forward_kinematics(&chassis.leg_R, &chassis_physical_config);

        /* =========================== 腿部协调处理 =========================== */

            leg_coordinate_handle();
    }


/* =========================== 2. 正动力学变换 =========================== */

    void vmc_forward_dynamics(VMC *vmc, const ChassisPhysicalConfig *physical_config)
    {
         if (vmc == NULL)
         {
             return;
         }

        /* =========================== 矩阵 =========================== */

            vmc->forward_kinematics.J_F_to_T.E.x1_1 =
                    physical_config->l1
                    * cosf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi3)
                    * sinf(vmc->forward_kinematics.fk_phi.phi1 - vmc->forward_kinematics.fk_phi.phi2)
                    / (vmc->forward_kinematics.fk_L0.L0
                    * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2));

            vmc->forward_kinematics.J_F_to_T.E.x1_2 =
                    physical_config->l1
                    * sinf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi3)
                    * sinf(vmc->forward_kinematics.fk_phi.phi1 - vmc->forward_kinematics.fk_phi.phi2)
                    / sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2);

            vmc->forward_kinematics.J_F_to_T.E.x2_1 =
                    physical_config->l4
                    * cosf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi2)
                    * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi4)
                    / (vmc->forward_kinematics.fk_L0.L0
                    * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2));

            vmc->forward_kinematics.J_F_to_T.E.x2_2 =
                    physical_config->l4
                    * sinf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi2)
                    * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi4)
                    / sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2);

        /* =========================== T1,T4 =========================== */

            Matrix_multiply(2, 2, vmc->forward_kinematics.J_F_to_T.array,
                            2, 1, vmc->forward_kinematics.Fxy_set_point.array,
                            vmc->forward_kinematics.T1_T4_set_point.array);
    }
```

## 定义如下图：

![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\2.Publish_InvertedPendulum_VMC.jpg)

| 力/力矩  | 含义     | 方向                        | 单位    |
| ----- | ------ | ------------------------- | ----- |
| $F$   | 关节力    | 沿$L_0$，向地面                | $N$   |
| $T_p$ | 关节等效力矩 | 过点$O$垂直于$L_0$，右手螺旋向外(逆时针) | $N·m$ |
| $T_1$ | 前关节力矩  | 右手螺旋向外(逆时针)               | $N·m$ |
| $T_4$ | 后关节力矩  | 右手螺旋向外(逆时针)               | $N·m$ |

## 1. 正解算：得到腿长$L_0$

###### 1.1 <mark>机械给定$l_1,l_2,l_3,l_4,l_5$</mark>（对于串联腿，$l_5=0$）

###### 1.2 获取$\phi_1,\phi_4,\phi1',\phi4'$

###### 1.2.1 关节电机编码器读取初始$\phi_1,\phi_4,\phi1',\phi4'$

###### 1.2.2 <mark>根据机械装配得到实际$\phi_1,\phi_4,\phi1',\phi4'$</mark>

###### 1.3 由图中可得$B,D$坐标：

            $B(x_B,y_B):x_B=l_1cos\phi_1, y_B=l_1sin\phi_1$

            $D(x_D,y_D):x_D=l_5+l_4cos\phi_4, y_D=l_4sin\phi_4$

###### 1.4 用$B(x_B,y_B)$和$D(x_D,y_D)$ 表示$l_{BD}^2$ ，并分别表示$C(x_C,y_C)$，可得：

            $l_{BD}^2=(x_D-x_B)^2+(y_D-y_B)^2$……1.4.1

            $x_C=x_B+l_2cos\phi_2=x_D+l_3cos\phi_3$……1.4.2

            $y_C=y_B+l_2sin\phi_2=y_D+l_3sin\phi_3$……1.4.3

###### 1.5 由1.4.1&1.4.2&1.4.3计算（推导见[五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)），可得：

            $\phi_2=2arctan(\frac{B_0+\sqrt{A_0^2+B_0^2-C_0^2}}{A_0+C_0})$……1.5.1

            其中$A_0=2l_2(x_D-x_B),B_0=2l_2(y_D-y_B),C_0=l_2^2+l_{BD}^2-l_3^2$

###### 1.6 由1.5.1&1.4.2&1.4.3,可得$C(x_C,y_C)$：

            $x_C=x_B+l_2cos\phi_2$

            $y_C=y_B+l_2sin\phi_2$

###### 1.7 构造$Rt\Delta CO_1D$,可得：

            $\phi_3=arctan(\frac{y_C-y_D}{x_C-x_D})$

###### 1.8 构造$Rt\Delta CO_2O$，可得：

        $L_0=\sqrt{(x_C-\frac{l_5}{2})^2+y_C^2}$

        $\phi_0=arctan(\frac{y_C}{x_C-\frac{l_5}{2}})$

## 2. 正动力学变换：得到关节力矩$\begin{bmatrix} T_1\\T_4 \end{bmatrix}$

###### 经计算（推导见[五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)），可得：

        $\begin{bmatrix} T_1\\T_4 \end{bmatrix}=\begin{bmatrix} \frac{l_1cos(\phi_0-\phi_3)sin(\phi_1-\phi_2)}{L_0sin(\phi_3-\phi_2)}&\frac{l_1sin(\phi_0-\phi_3)sin(\phi_1-\phi_2)}{sin(\phi_3-\phi_2)}\\ \frac{l_4cos(\phi_0-\phi_2)sin(\phi_3-\phi_4)}{L_0sin(\phi_3-\phi_2)} & \frac{l_4sin(\phi_0-\phi_2)sin(\phi_3-\phi_4)}{sin(\phi_3-\phi_2)}\end{bmatrix}\begin{bmatrix} T_p\\F \end{bmatrix}$

# LQR 控制系统

## Matlab代码

```get_k_length.m
function K = get_k_length(leg_length, dt)

    % ============================= 1.1 机械量 ============================= %

    R = 0.06;               % 轮毂半径（与clion中的wheel_radius一致）
    l = 0.02363;            % 机体重心到机体转轴的距离
    B_L = 0.554;            % 机体长度（x方向 纯底盘）
    % B_L = 0.554 + ;       % 机体长度（x方向 加云台）
    B_W = 0.200;            % 机体宽度（y方向）
    B_H = 0.167;            % 机体高度（z方向）

    m_w = 0.167;            % 轮毂质量（不含轮毂电机）（与clion中的wheel_weight一致）
    m_p = 1.865;            % 摆杆质量（含轮毂电机不含关节电机）
    M = 11.255;             % 机体质量（含关节电机 纯底盘）（与clion中的body_weight一致）
    % M = 11.255 + 2.494;   % 机体质量（含关节电机 加云台）

    g = 9.80665;                % 重力加速度

    % ============================= 1.2 距离 ============================= %

    %此处理想化
    L = leg_length/2;                               % 摆杆重心到轮毂轴线的距离
    L_M = leg_length/2;                             % 摆杆重心到机体转轴的距离

    % ============================= 1.2 转动惯量 ============================= %

    I_w = (1/2)*m_w*R^2;                            % 轮毂转子的转动惯量
    I_M = (1/12)*M*(B_L^2+B_H^2);                   % 机体绕质心的转动惯量（x轴）
    I_p = (1/12) * m_p * ((L + L_M)^2 + 0.05^2);    % 摆杆绕质心的转动惯量

    % ===================== 1.6 M矩阵 (1.3-1.5为推导) ===================== %

    M11 = I_p + m_p*L^2 + M*(L + L_M)^2;
    M12 = (m_p + M)*L + M*L_M;
    M13 = -M*l*(L + L_M);

    M21 = m_p*L*R + M*R*(L + L_M);
    M22 = I_w/R + R*(m_w + m_p + M);
    M23 = -R*M*l;

    M31 = -M*l*(L + L_M);
    M32 = -M*l;
    M33 = I_M + M*l^2;

    M_mat = [ M11,  M12,  M13 ;
              M21,  M22,  M23 ;
              M31,  M32,  M33 ];

    % ============================= 1.6 Z矩阵 ============================= %

    Z11 = (m_p + M)*g*L + M*g*L_M;
    Z32 = M*g*l;

    Z_mat = [ Z11,    0,   -1,    1 ;
                0,    0,    1,    0 ;
                0,  Z32,    0,    1 ];

    % ============================= 1.7 G矩阵 ============================= %

    G = M_mat \ Z_mat;

    % ============================= 1.9 A矩阵 ============================= %

    A_mat = [      0,       1,       0,       0,       0,       0 ;
              G(1,1),       0,       0,       0,  G(1,2),       0 ;
                   0,       0,       0,       1,       0,       0 ;
              G(2,1),       0,       0,       0,  G(2,2),       0 ;
                   0,       0,       0,       0,       0,       1 ;
              G(3,1),       0,       0,       0,  G(3,2),       0 ];

    % ============================= 1.8 B矩阵 ============================= %

    B_mat = [      0,        0 ;
              G(1,3),   G(1,4) ;
                   0,       0 ;
              G(2,3),   G(2,4) ;
                   0,        0 ;
              G(3,3),   G(3,4) ];

    % ============================= 2.1 Q矩阵 ============================= %

    % 根据实际情况设定Q
    % 权重顺序: θ, θ', x, x', φ, φ'
    Q_mat = diag([1, 1, 400, 1, 1, 1]);

    % ============================= 2.1 R矩阵 ============================= %

    %根据实际情况设定R
    % 权重顺序: 轮毂 关节
    R_mat = diag([1, 0.25]);

    % ============================= 2.2 K矩阵 ============================= %

    K = lqrd(A_mat, B_mat, Q_mat, R_mat, dt);


end
```

```get_k.m
% ============================= 3.1 考虑不同腿长 ============================= %

% 根据机械结构设定最小&最大腿长 此处为100mm~400mm 步长10mm
leg=0.1:0.01:0.4;

% 根据控制频率设置dt 此处为0.001 （与clion中CHASSIS_PERIOD保持一致）
dt = 0.001;

% 遍历每个腿长值
for j = 1:length(leg)

    % 计算当前腿长下的K
    k = get_k_length(leg(j), dt);

    % 提取K第一行元素
    k11(j) = k(1,1); k12(j) = k(1,2); k13(j) = k(1,3);
    k14(j) = k(1,4); k15(j) = k(1,5); k16(j) = k(1,6);

    % 提取K第二行元素
    k21(j) = k(2,1); k22(j) = k(2,2); k23(j) = k(2,3);
    k24(j) = k(2,4); k25(j) = k(2,5); k26(j) = k(2,6);

    % 打印腿长
    % fprintf('leg(%d) = %ff\n', j, leg(j));

end

% ============================= 3.1 多项式拟合 ============================= %

a11=polyfit(leg,k11,3); 
a12=polyfit(leg,k12,3);
a13=polyfit(leg,k13,3);
a14=polyfit(leg,k14,3);
a15=polyfit(leg,k15,3);
a16=polyfit(leg,k16,3);

a21=polyfit(leg,k21,3);
a22=polyfit(leg,k22,3);
a23=polyfit(leg,k23,3);
a24=polyfit(leg,k24,3);
a25=polyfit(leg,k25,3);
a26=polyfit(leg,k26,3);

% ============================= 打印K ============================= %

fprintf('float wheel_fitting_factor[6][4] = \n { \n');
fprintf('{%ff,%ff,%ff,%ff},\n', a11);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a12);
fprintf('{%ff,%ff,%ff,%ff},\n', a13);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a14);
fprintf('{%ff,%ff,%ff,%ff},\n', a15);
fprintf('{%ff,%ff,%ff,%ff}\n', a16);
fprintf('};\n\n');

fprintf('float joint_fitting_factor[6][4] = \n { \n');
fprintf('{%ff,%ff,%ff,%ff},\n', a21);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a22);
fprintf('{%ff,%ff,%ff,%ff},\n', a23);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a24);
fprintf('{%ff,%ff,%ff,%ff},\n', a25);
fprintf('{%ff,%ff,%ff,%ff}\n', a26);
fprintf('};\n\n');

fprintf('end\n');
```

## Clion代码

```lqr.c
/* ============================= 初始化K矩阵 ============================= */

    float wheel_K_L[6] = {0, 0, 0, 0, 0, 0};
    float joint_K_L[6] = {0, 0, 0, 0, 0, 0};

    float wheel_K_R[6] = {0, 0, 0, 0, 0, 0};
    float joint_K_R[6] = {0, 0, 0, 0, 0, 0};

/* ============================= 复制matlab打印的K到这里 ============================= */

    float wheel_fitting_factor[6][4] = 
    { 
        {-170.798425f,195.694047f,-127.337190f,0.491047f},
        {1.373709f,-7.074693f,-10.618367f,0.090683f},

        {-468.317081f,500.840108f,-195.418777f,11.744454f},
        {-152.587412f,163.012539f,-70.492569f,1.840569f},

        {17.870288f,-9.178644f,-3.319571f,4.158944f},
        {10.229144f,-6.314713f,-0.611700f,1.730143f}
    };

    float joint_fitting_factor[6][4] = 
    { 
        {458.416966f,-428.336808f,129.097564f,9.579293f},
        {39.823875f,-41.350925f,18.292931f,0.964693f},

        {364.246433f,-246.000640f,-0.715596f,37.362168f},
        {115.544891f,-73.075025f,-4.893174f,15.491801f},

        {126.130387f,-142.228626f,59.688105f,-4.978932f},
        {50.807092f,-58.010530f,24.696537f,-1.821224f}
    };

/* ============================= 3.1 不同腿长下进行多项式拟合 ============================= */

    void chassis_K_matrix_fitting(float L0, float K[6], const float KL[6][4]) 
    {
        for (int i = 0; i < 6; i++)
        {
            K[i] = KL[i][0] * powf(L0, 3) + KL[i][1] * powf(L0, 2) + KL[i][2] * powf(L0, 1) + KL[i][3] * powf(L0, 0);
        }
    }
```

```chassis_task.c
/* ============================= 4. 计算力矩 轮毂 ============================= */

    static void wheel_calc(void)
    {

        /* ============================= 3.1 不同腿长下进行多项式拟合 ============================= */

            chassis_K_matrix_fitting(chassis.leg_L.vmc.forward_kinematics.fk_L0.L0, wheel_K_L, wheel_fitting_factor);
            chassis_K_matrix_fitting(chassis.leg_R.vmc.forward_kinematics.fk_L0.L0, wheel_K_R, wheel_fitting_factor);

        /* ============================= 3.2 加入目标输入 ============================= */

            chassis.leg_L.wheel_torque = - wheel_K_L[0] * (chassis.leg_L.state_variable_feedback.theta - THETA_OFFSET)
                                         - wheel_K_L[1] * (chassis.leg_L.state_variable_feedback.theta_dot - 0.0f)
                                         - wheel_K_L[2] * (chassis.leg_L.state_variable_feedback.x - 0.0f)
                                         - wheel_K_L[3] * (chassis.leg_L.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
                                         - wheel_K_L[4] * (chassis.leg_L.state_variable_feedback.phi - 0.0f)
                                         - wheel_K_L[5] * (chassis.leg_L.state_variable_feedback.phi_dot - 0.0f);

            chassis.leg_R.wheel_torque = - wheel_K_R[0] * (chassis.leg_R.state_variable_feedback.theta - THETA_OFFSET)
                                         - wheel_K_R[1] * (chassis.leg_R.state_variable_feedback.theta_dot - 0.0f)
                                         - wheel_K_R[2] * (chassis.leg_R.state_variable_feedback.x - 0.0f)
                                         - wheel_K_R[3] * (chassis.leg_R.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
                                         - wheel_K_R[4] * (chassis.leg_R.state_variable_feedback.phi - 0.0f)
                                         - wheel_K_R[5] * (chassis.leg_R.state_variable_feedback.phi_dot - 0.0f);

        /* ============================= 4.2 根据机械结构加负号 ============================= */

            chassis.leg_L.wheel_torque *= -1;

        /* ============================= 限幅 ============================= */

            VAL_LIMIT(chassis.leg_L.wheel_torque, MIN_WHEEL_TORQUE, MAX_WHEEL_TORQUE);
            VAL_LIMIT(chassis.leg_R.wheel_torque, MIN_WHEEL_TORQUE, MAX_WHEEL_TORQUE);

    }

/* ============================= 4. 计算力矩 关节 ============================= */

    static void joint_calc(void)
    {

        /* ============================= Tp ============================= */

            /* ============================= 3.1 不同腿长下进行多项式拟合 ============================= */

                chassis_K_matrix_fitting(chassis.leg_L.vmc.forward_kinematics.fk_L0.L0, joint_K_L, joint_fitting_factor);
                chassis_K_matrix_fitting(chassis.leg_R.vmc.forward_kinematics.fk_L0.L0, joint_K_R, joint_fitting_factor);

            /* ============================= 3.2 加入目标输入 ============================= */

                chassis.leg_L.vmc.forward_kinematics.Fxy_set_point.E.Tp_set_point =  - joint_K_L[0] * (chassis.leg_L.state_variable_feedback.theta - THETA_OFFSET)
                                                                                     - joint_K_L[1] * (chassis.leg_L.state_variable_feedback.theta_dot - 0.0f)
                                                                                     - joint_K_L[2] * (chassis.leg_L.state_variable_feedback.x - 0.0f)
                                                                                     - joint_K_L[3] * (chassis.leg_L.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
                                                                                     - joint_K_L[4] * (chassis.leg_L.state_variable_feedback.phi - 0.0f)
                                                                                     - joint_K_L[5] * (chassis.leg_L.state_variable_feedback.phi_dot - 0.0f);

                chassis.leg_R.vmc.forward_kinematics.Fxy_set_point.E.Tp_set_point =  - joint_K_R[0] * (chassis.leg_R.state_variable_feedback.theta - THETA_OFFSET)
                                                                                     - joint_K_R[1] * (chassis.leg_R.state_variable_feedback.theta_dot - 0.0f)
                                                                                     - joint_K_R[2] * (chassis.leg_R.state_variable_feedback.x - 0.0f)
                                                                                     - joint_K_R[3] * (chassis.leg_R.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
                                                                                     - joint_K_R[4] * (chassis.leg_R.state_variable_feedback.phi - 0.0f)
                                                                                     - joint_K_R[5] * (chassis.leg_R.state_variable_feedback.phi_dot - 0.0f);

        /* =========================== 2. 正动力学变换 =========================== */

            vmc_forward_dynamics(&chassis.leg_L.vmc, &chassis_physical_config);
            vmc_forward_dynamics(&chassis.leg_R.vmc, &chassis_physical_config);

            /* =========================== 提取力矩 =========================== */

                chassis.leg_L.joint_F_torque = chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T1_set_point;
                chassis.leg_L.joint_B_torque = chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T4_set_point;

                chassis.leg_R.joint_F_torque = chassis.leg_R.vmc.forward_kinematics.T1_T4_set_point.E.T1_set_point;
                chassis.leg_R.joint_B_torque = chassis.leg_R.vmc.forward_kinematics.T1_T4_set_point.E.T4_set_point;

        /* ============================= 4.2 根据机械结构加负号 ============================= */

            chassis.leg_L.joint_F_torque = - chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T1_set_point;
            chassis.leg_L.joint_B_torque = - chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T4_set_point;

        /* ============================= 限幅 ============================= */

            VAL_LIMIT(chassis.leg_L.joint_F_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
            VAL_LIMIT(chassis.leg_L.joint_B_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
            VAL_LIMIT(chassis.leg_R.joint_F_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
            VAL_LIMIT(chassis.leg_R.joint_B_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);

    }

/* =========================== 底盘观测器更新 ====================== */

    static void chassis_observer_update(void)
    {

        /* =========================== 获取传感器数据 ====================== */

            get_IMU_info();

        /* =========================== 更新底盘变量 ====================== */

            chassis_variable_update();

        /* =========================== 1. 正解算 =========================== */

            vmc_calc();

    } 

/* ============================= 底盘使能任务 ============================= */

    static void chassis_enable_task(void)
    {

        /* ============================= 4. 计算力矩 轮毂 ============================= */

            wheel_calc();

        /* ============================= 4. 计算力矩 关节 ============================= */

            joint_calc();

        /* ============================= 倒地自救 ============================= */

            chassis_selfhelp();

    } 

/* =========================== 底盘任务 =========================== */

    void chassis_task(void)
    {

        /* =========================== 获取底盘遥控器信息 =========================== */

            chassis_remote_cmd();

        /* =========================== 底盘观测器更新 =========================== */

            chassis_observer_update();

        /* =========================== 根据拨杆设置任务模式 =========================== */

            /* iss：后面要加上spin */

            switch (chassis.chassis_ctrl_mode)
            {

            /* =========================== 失能模式 进入底盘失能任务 ============================= */

                case CHASSIS_DISABLE:
                {
                    chassis_disable_task();
                    break;
                }

            /* =========================== 初始化模式 进入底盘初始化任务 ============================= */

                case CHASSIS_INIT:
                {
                    chassis_init_task();
                    break;
                }

            /* =========================== 使能或者小陀螺模式 进入底盘使能任务 =========================== */

                case CHASSIS_ENABLE:
                case CHASSIS_SPIN:
                {
                    chassis_enable_task();
                    break;
                }

                default:
                {
                    break;
                }
            }

        /* =========================== 发送力矩 =========================== */

            MIT_send_torque_task(chassis.leg_L.joint_F_torque,
                                 chassis.leg_L.joint_B_torque,
                                 chassis.leg_R.joint_F_torque,
                                 chassis.leg_R.joint_B_torque,
                                 chassis.leg_L.wheel_torque,
                                 chassis.leg_R.wheel_torque,
                                 0,0,0,0);

    }
```

## 定义如下图：

 ![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\2.Publish_InvertedPendulum_LQR.jpg)

| 角度       | 含义                                    | 正方向 | 单位    |
| -------- |:------------------------------------- | --- | ----- |
| $\theta$ | 摆杆与竖直方向的夹角，等于$\alpha-\phi$            | 顺时针 | $rad$ |
| $\phi$   | 机体与水平方向的夹角，等于pitch                    | 逆时针 | $rad$ |
| $\alpha$ | 机体竖直方向与摆杆的夹角，等于$\phi_0-\frac{\pi}{2}$ | 顺时针 | $rad$ |

| 位移/距离 | 含义           | 正方向 | 单位  |
| ----- | ------------ | --- | --- |
| $x$   | 轮毂位移         | 向右  | $m$ |
| $x_p$ | 摆杆质心位移       | 向右  | $m$ |
| $x_M$ | 机体质心位移       | 向右  | $m$ |
| $B_L$ | 机体长度（x方向）    |     | $m$ |
| $B_W$ | 机体宽度（y方向）    |     | $m$ |
| $B_H$ | 机体高度（z方向）    |     | $m$ |
| $L$   | 摆杆重心到轮毂轴线的距离 |     | $m$ |
| $L_M$ | 摆杆重心到机体转轴的距离 |     | $m$ |
| $l$   | 机体重心到机体转轴的距离 |     | $m$ |
| $R$   | 轮毂半径         |     | $m$ |

| 力/力矩  | 含义           | 正方向                  | 单位    |
| ----- | ------------ | -------------------- | ----- |
| $T$   | 轮毂电机的输出力矩    | 右手螺旋向内(顺时针)          | $N·m$ |
| $T_p$ | 关节电机等效输出力矩   | 绕两关节连线中点，右手螺旋向内(顺时针) | $N·m$ |
| $N$   | 轮毂对摆杆的力的水平分量 | 向右                   | $N$   |
| $P$   | 轮毂对摆杆的力的竖直分量 | 向上                   | $N$   |
| $N_M$ | 摆杆对机体的力的水平分量 | 向右                   | $N$   |
| $P_M$ | 摆杆对机体的力的竖直分量 | 向上                   | $N$   |
| $N_f$ | 地面对轮毂的摩擦力    | 向右                   | $N$   |

| 质量    | 含义                                                              | 单位   |
| ----- | --------------------------------------------------------------- | ---- |
| $m_w$ | 轮毂质量（不含轮毂电机）                                                    | $kg$ |
| $m_p$ | 摆杆质量（含轮毂电机不含关节电机，等于$\frac{m_{l_1}+m_{l_2}+m_{l_3}+m_{l_4}}{2}$） | $kg$ |
| $M$   | 机体质量（含关节电机）                                                     | $kg$ |

| 转动惯量  | 含义               | 单位       |
| ----- | ---------------- | -------- |
| $I_w$ | 轮毂转子的转动惯量        | $kg·m^2$ |
| $I_p$ | 摆杆绕质心的转动惯量       | $kg·m^2$ |
| $I_M$ | 机体绕质心的转动惯量($x$轴) | $kg·m^2$ |

## 1. 计算$A,B$

###### 1.1 <mark>机械给定$R,l,m_w,m_p,M,g,B_L,B_H$</mark>

###### 1.2 由上文得到的腿长$L_0$，可得：

            $L_0=L+L_M$，<mark>此处理想化</mark>为$L=\frac{L_0}{2},L_M=\frac{L_0}{2}$

            $I_w=\frac{m_wR^2}{2},I_M=\frac{M(B_L^2+B_H)^2}{12},I_p=\frac{ m_p [(L + LM)^2 + 0.05 ^ 2]}{12}$

            （$I_w,I_M$用sw提供的也可以）

###### 1.3 运动学分析

###### 1.3.1 对轮毂：

                牛顿第二定律：$m_w x''=N_f-N$……1.3.1.1

                转动定律：$I_w \frac{x''}{R}=T-N_fR$……1.3.1.2

###### 1.3.2 对摆杆：

                位移：

                    $x_p=x+Lsin\theta$

                    $y_p=Lcos\theta$

                加速度：

                    $x_p''=x''+L\theta''cos\theta-L\theta'^2sin\theta$

                    $y_p''=-L\theta''sin\theta-L\theta'^2cos\theta$

                牛顿第二定律：

                    $N-N_M=m_px_p''$……1.3.2.1

                    $P-P_M-m_pg=m_py_p''$……1.3.2.2

                转动定律：

                    $Ip \theta''=(PL+P_ML_M)sin\theta-(NL+N_ML_M)cos\theta-T+T_P$……1.3.2.3

###### 1.3.3 对机体：

                位移：

                    $x_M=x+(L+L_M)sin\theta-lsin\phi$

                    $y_M=(L+L_M)cos\theta+lcos\phi$

                加速度：

                    $x_M''=x''+(L+L_M)(\theta''cos\theta-\theta'^2sin\theta)-l(\phi''cos\phi-\phi'^2sin\phi)$

                    $y_M''=-(L+L_M)(\theta''sin\theta+\theta'^2cos\theta)-l(\phi''sin\phi-\phi'^2cos\phi)$

                牛顿第二定律：

                    $N_M=Mx_M''$……1.3.3.1

                    $P_M-Mg=M y_M''$……1.3.3.2

                转动定律：

                    $I_M\phi''=T_p+N_Mlcos\phi+P_Mlsin\phi$……1.3.3.3

###### 1.4 线性化：$sin\theta=\theta,cos\theta=1,sin\phi=\phi,cos\phi=1$，并忽略高阶项

            由1.3.2.1，可得：$N-N_M=m_p(x''+L\theta'')$……1.4.1

            由1.3.2.2，可得：$P=P_M-m_pg$……1.4.2

            由1.3.2.3，可得：$Ip \theta''=(PL+P_ML_M)\theta-NL-N_ML_M-T+T_P$……1.4.3

            由1.3.3.1，可得：$N_M=M[x''+(L+L_M)\theta''-l\phi'']$……1.4.4

            由1.3.3.2，可得：$P_M=Mg$……1.4.5

            由1.3.3.3，可得：$I_M\phi''=T_p+N_Ml+P_Ml\phi$……1.4.6

###### 1.5 消去$N,P,N_M,P_M$，得到最终方程

            由1.3.1.1&1.3.1.2，可得：$N=\frac{T}{R}-(\frac{I_w}{R^2}+M_w)X''$……1.5.1

            由1.4.2&1.4.3&1.4.4&1.4.5&1.5.1，可得：

            $[I_p+m_pL^2+M(L+L_M)^2]\theta''+[(m_p+M)L+ML_M]x''+[-Ml(L+L_M)]\phi''=[(m_p+M)gL+MgL_M]\theta-T+T_p$……1.5.2

            由1.4.1&1.4.4&1.5.1，可得：

            $[m_pLR+MR（L+L_M)]\theta''+[\frac{I_w}{R}+R(M_w+m_p+M)]x''+[-RMl]\phi''=T$……1.5.3

            由1.4.4&1.4.5&1.4.6，可得：

            $I_M\phi''=T_p+[x''+(L+L_M)\theta''-l\phi'']Ml+Mgl\phi$……1.5.4

###### 1.6 将1.5.2&1.5.3&1.5.4整理为矩阵，可得：

            $\begin{bmatrix}M_{11}&M_{12}&M_{13}\\ M_{21}&M_{22}&M_{23}\\M_{31}&M_{32}&M_{33} \end{bmatrix} \begin{bmatrix} \theta''\\ x'' \\ \phi''\end{bmatrix}=\begin{bmatrix}Z_{11}&0&-1&1\\ 0&0&1&0\\0&Z_{32}&0&1\end{bmatrix}\begin{bmatrix}\theta \\ \phi \\ T \\T_p \end{bmatrix}$……1.6.1

            其中

            $M_{11}=I_p+m_pL^2+M(L+L_M)^2,M_{12}=(m_p+M)L+ML_M,M_{13}=-Ml(L+L_M)$

            $M_{21}=m_pLR+MR（L+L_M),M_{22}=\frac{I_w}{R}+R(M_w+m_p+M),M_{23}=-RMl$

            $M_{31}=-Ml(L+L_M),M_{32}=-Ml,M_{33}=I_M+Ml^2$

            $Z_{11}=(m_p+M)gL+MgL_M,Z_{32}=Mgl$

###### 1.7 记$G=M^{-1}Z$,由1.6.1可得：

            $\begin{bmatrix} \theta''\\ x'' \\ \phi''\end{bmatrix}=\begin{bmatrix}G_{11}&G_{12}&G_{13}&G_{14}\\ G_{21}&G_{22}&G_{23}&G_{24}\\G_{31}&G_{32}&G_{33}&G_{34}\end{bmatrix}\begin{bmatrix}\theta \\ \phi \\ T \\T_p \end{bmatrix}$……1.7.1

###### 1.8 由1.7.1，可得：

            $\theta''=G_{11}\theta+G_{12}\phi+G_{13}T+G_{14}T_p$……1.8.1

            $x''=G_{21}\theta+G_{22}\phi+G_{23}T+G_{24}T_p$……1.8.2

            $\phi''=G_{31}\theta+G_{32}\phi+G_{33}T+G_{34}T_p$……1.8.3

            定义

            $X=\begin{bmatrix}\theta \\ \theta'\\x\\x'\\ \phi\\ \phi'\end{bmatrix},u=\begin{bmatrix}T \\T_p\end{bmatrix}$

            根据1.8.1&1.8.2&1.8.3，可得：

            $X'=\begin{bmatrix} \theta' \\ \theta'' \\ x'\\ x''\\ \phi'\\ \phi''\end{bmatrix}=\begin{bmatrix} \theta' \\ G_{11}\theta+G_{12}\phi+G_{13}T+G_{14}T_p \\ x'\\ G_{21}\theta+G_{22}\phi+G_{23}T+G_{24}T_p\\ \phi'\\ G_{31}\theta+G_{32}\phi+G_{33}T+G_{34}T_p\end{bmatrix}$

            根据$X'=AX+Bu$，可得：

            $A=\begin{bmatrix}0&1&0&0&0&0\\G_{11}&0&0&0&G_{12}&0\\0&0&0&1&0&0\\G_{21}&0&0&0&G_{22}&0\\0&0&0&0&0&1 \\G_{31}&0&0&0&G_{32}&0 \end{bmatrix},B=\begin{bmatrix}0&0\\G_{13}&G_{14}\\0&0\\G_{23}&G_{24}\\0&0\\G_{33}&G_{34}\end{bmatrix}$

## 2.  计算$K$

###### 2.1 <mark>根据实际情况，设定Q,R</mark>

            <mark>权重越大 能量消耗越小 收敛越快</mark>

            $Q = \begin{bmatrix}Q_{11}&0&0&0&0&0 \\ 0&Q_{22}&0&0&0&0&\\0&0&Q_{33}&0&0&0\\0&0&0&Q_{44}&0&0\\0&0&0&0&Q_{55}&0\\0&0&0&0&0&Q_{66}\end{bmatrix}$

            $Q$各项分别代表

            $\theta$的权重 $\theta'$的权重 $x$的权重 $x'$的权重 $\phi$的权重 $\phi'$的权重

            $R =\begin{bmatrix}R_{11}&0\\0&R_{22}\end{bmatrix}$

            $R$各项分别代表

            轮毂的权重 关节的权重

###### 2.2 <mark>根据控制频率设置dt</mark>，调用lqrd函数，求离散lqr

            $K = lqrd(A,B,Q,R,dt)$

            $K$各项分别代表 

            轮毂$\theta$的增益 轮毂$\theta'$的增益 轮毂$x$的增益 轮毂$x'$的增益 轮毂$\phi$的增益 轮毂$\phi'$的增益

            关节$\theta$的增益 关节$\theta'$的增益 关节$x$的增益 关节$x'$的增益 关节$\phi$的增益 关节$\phi'$的增益  

## 3. 计算$u$

###### 3.1 <mark>根据机械结构设定最小&最大腿长</mark>，在腿长区间内每10mm求一次K，并进行拟合

        $K_{ij}(L_0)=p_{0|ij}+p_{1|ij}L_0+p_{2|ij}L_0^2+p_{3|ij}L_0^3$

###### 3.2 为使机器人跟踪轨迹，还需在系统输入中加入目标输入，即：

            $u=-K(X_d-X)=-\begin{bmatrix}K_{11}&K_{12}&K_{13}&K_{14}&K_{15}&K_{16}\\K_{21}&K_{22}&K_{23}&K_{24}&K_{25}&K_{26}\end{bmatrix}(\begin{bmatrix}\theta_d \\ \theta_d' \\ x_d \\ x_d' \\ \phi_d\\ \phi_d' \end{bmatrix}-\begin{bmatrix}\theta \\ \theta' \\ x \\ x' \\ \phi\\ \phi' \end{bmatrix})=\begin{bmatrix}K_{11}&K_{12}&K_{13}&K_{14}&K_{15}&K_{16}\\K_{21}&K_{22}&K_{23}&K_{24}&K_{25}&K_{26}\end{bmatrix}(\begin{bmatrix}\theta_d \\ 0 \\ 0 \\ x_d' \\ 0\\0\end{bmatrix}-\begin{bmatrix}\theta \\ \theta' \\ x \\ x' \\ \phi\\ \phi' \end{bmatrix})$

其中$\theta_d$为<mark>根据情况设置的补偿</mark>，$x_d'$为根据遥控器数据映射出的速度

## 4. 计算力矩$\begin{bmatrix}T \\T_p\end{bmatrix}$

###### 4.1 计算力矩

            $u=K(L_0)(X_d-X)$

            根据$u=\begin{bmatrix}T \\T_p\end{bmatrix}$，可得：

            $T=-K_{11}(\theta-\theta_d)-K_{12}\theta'-K_{13}x-K_{14}(x'-x_d')-K_{15}\phi-K_{16}\phi'$

            $T_p=-K_{21}(\theta-\theta_d)-K_{22}\theta'-K_{23}x-K_{24}(x'-x_d')-K_{25}\phi-K_{26}\phi'$

###### 4.2 <mark>根据机械结构调整力矩</mark>

> 参考文章：
> 
> 1. [RoboMaster平衡步兵机器人控制系统设计 - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/563048952)
> 
> 2. [五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)
> 
> 3. [两轮自平衡机器人LQR-模糊控制算法研究 - 道客巴巴](https://www.doc88.com/p-45329024185491.html?r=1)
> 
> 4. [[RM2025 平衡步兵电控开源]山海机甲战队完整形态技术文档软件设计开源-RoboMaster 社区](https://bbs.robomaster.com/article/696393?source=8)
