> 编者：
> 
>     SZTU悍匠平步电控
> 
> 整体思路：
> 
>     根据IMU读出$\phi,\phi'$
> 
>     再计算出$x,x',x''$：
> 
>         $x'$：将轮毂电机反馈的角速度映射到大地系，计算出机体速度
> 
>                 ，再用卡尔曼滤波融合$\begin{bmatrix}x' \\x'' \end{bmatrix}$，获得$x'$的最佳估计，以防轮毂打滑
> 
>         $x$：$x'$积分
> 
>         $x''$：$x'$求导，并通过低通滤波
> 
>     最后计算出$\theta,\theta',\theta''$：
> 
>         $\theta$：根据定义计算
> 
>         $\theta'$：$\theta$求导
> 
>         用卡尔曼滤波融合$\begin{bmatrix}\theta\\ \theta'\end{bmatrix}$，获得$\theta,\theta'$的最佳估计
> 
>         $\theta''$：$\theta'$求导，并通过低通滤波
> 
> 目录：
> 
> |
> 
> ——卡尔曼滤波
> 
>         |
> 
>         ——Clion代码
> 
>         ——预测
> 
>         ——更新
> 
>         ——反馈
> 
> |
> 
> ——速度解算
> 
>         |
> 
>         ——Clion代码
> 
>         ——定义
> 
>         ——角速度
> 
>         —速度
> 
>         ——估计$x'$，估计$\theta,\theta'$
> 
> |
> 
> ——参考文章
> 
> <mark>套用只需按实际情况改变高亮部分数据</mark>

# 卡尔曼滤波：让估计的状态尽可能接近真实值

## 代码：

> ```kalman_filter.c
> /* =========================== 执行卡尔曼滤波 ============================= */
> 
>     float *Kalman_Filter_Update(KalmanFilter_t *kf)
>     {
> 
>         /* =========================== 1.1 获取量测信息 ============================= */
> 
>             Kalman_Filter_Measure(kf);
> 
>         /* =========================== 1.2 先验估计 X_prev(k) = A·X_pred(k-1)+ B·u ============================= */
> 
>             Kalman_Filter_xhatMinusUpdate(kf);
> 
>         /* =========================== 2. 预测更新 P_prev(k) = A·P_pred(k-1)·A^T + Q ============================= */
> 
>             Kalman_Filter_PminusUpdate(kf);
> 
>             /* =========================== 量测有效,更新 ============================= */
> 
>                 if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0)
>                 {
> 
>                     /* =========================== 2. 量测更新 K(k) = P_prev(k)·H^T / (H·P_prev(k)·H^T + R) ============================= */
> 
>                         Kalman_Filter_SetK(kf);
> 
>                     /* =========================== 2. 融合 X_pred(k) = X_prev(k) + K(k)·(z(k) - H·X_prev(k)) ============================= */
> 
>                         Kalman_Filter_xhatUpdate(kf);
> 
>                     /* =========================== 2. 修正方差 P_pred(k) = (I-K(k)·H)·P_prev(k) ============================= */
> 
>                         Kalman_Filter_P_Update(kf);
>                 }
> 
>         /* =========================== 量测无效,仅预测 ============================= */
> 
>             else
>             {
> 
>                 /* =========================== X_pred(k) = X_prev(k) ============================= */
> 
>                     memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
> 
>                 /* =========================== P_pred(k) = P_prev(k) ============================= */
> 
>                     memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
>             }
> 
>         /* =========================== 避免滤波器过度收敛 ============================= */
> 
>             for (uint8_t i = 0; i < kf->xhatSize; i++)
>             {
>                 if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i])
>                     kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
>             }
> 
>         /* =========================== X = X_pred 并返回 ============================= */
> 
>             memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
>             return kf->FilteredValue;
>     }
> ```

## 1.预测：根据$k-1$时刻状态预测$k$时刻状态

![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\1.Publish_Wheel_Kalman.png)

#### 1.1 质量为m的机器人匀速自由运动

定义机器人的状态为$X$，由于状态$X$与位置$x$和速度$x'$有关，定义状态$X=\begin{bmatrix}x \\x' \end{bmatrix} $

x和x'存在关系，将x和x'的关系，用协方差矩阵表示，可得：不确定性$P=\begin{bmatrix}\sum_{xx} \sum_{xx'} \\\sum_{x'x} \sum_{x'x'} \end{bmatrix}$

> $i$和$j$间的关系可用协方差矩阵$\sum_{ij}$表示
> 
> 矩阵$i,j$位置的元素是第$i$个变量和第$j$个变量之间的相关程度(协方差)

根据运动学，可得：$x_k=x_{k-1}+\Delta t x'_{k-1},x'_k=x'_{k-1}$

令$X_k^-=AX_{k-1}^+$，可得：<mark>$A=\begin{bmatrix}1&\Delta t\\0&1\end{bmatrix}$</mark>(有时也用$F$表示，此处为不与力$F$混淆，使用$A$)

令$P_k^-=AP_{k-1}^+A^T$

> $Cov(x)=\sum$，则$Cov(Ax)=A\sum A^T$

#### 1.2 外部给该机器人力$F$，沿机器人运动正方向，并考虑外部不可控扰动Q

根据运动学，可得：$x_k=x_{k-1}+\Delta t x'_{k-1}+\frac{1}{2}\frac{F}{m}\Delta t^2,x'_k=x'_{k-1}+\frac{F}{m}\Delta t,x_k''=\frac{F}{m}$

令$u=\begin{bmatrix}F\end{bmatrix}$，$X_k^-=AX_{k-1}^++Bu_{k-1}$，可得：$B=\begin{bmatrix}\frac{\Delta t^2}{2m}\\ \frac{\Delta t}{m}\end{bmatrix}$

令$P_k^-=AP_{k-1}^+A^T+\Gamma Q \Gamma^T$，其中， $\Gamma$一般为单位阵$I$

## 2. 更新：融合预测值$X_k^-$与$k$时刻传感器测量值$z_k$

令$X_k^+=X_k^-+K_k(z_k-HX_k^-)$，即最终估计的系统当前状态

令$P_k^+=\Gamma P_k^- -K_kHP_k^-$，即估计状态的不确定性

其中卡尔曼增益$K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}$，$H$一般为单位阵$I$

<mark>$Q,R$需根据实际调整</mark> ，相信测量值则调小$R$，相信预测值则调小$Q$

## 3.反馈：

$X_k^+,P_k^+$进入下一轮卡尔曼滤波

经过多轮滤波，不确定性$P$越来越小，即实现状态$X$尽可能接近真实值

> <区分>控制器：根据目标值与$X_k^+$的差值计算力$F$,作为$u$输入系统，使系统趋于目标值

# 速度解算

## Clion代码

```theta_kalman_filter.c
/* =========================== 2.4 θ θ' 融合 估计 θ θ' =========================== */

    void theta_KF_calc(KalmanFilter_t *Theta_EstimateKF, Leg *leg, float theta, float theta_dot)
    {

        /* =========================== 卡尔曼滤波器测量值更新 =========================== */

            Theta_EstimateKF->MeasuredVector[0] = theta;
            Theta_EstimateKF->MeasuredVector[1] = theta_dot;

        /* =========================== 卡尔曼滤波器更新 =========================== */

            Kalman_Filter_Update(Theta_EstimateKF);

        /* ===========================  设置为机体θ θ' =========================== */

            leg->state_variable_feedback.theta = Theta_EstimateKF->FilteredValue[0];
            leg->state_variable_feedback.theta_dot = Theta_EstimateKF->FilteredValue[1];

    }
```

```speed_kalman_filter.c
/* =========================== 2.4 x' x''融合 估计x' =========================== */

    void Speed_KF_calc(KalmanFilter_t *Speed_EstimateKF, Leg *leg, float vel, float acc)
    {

        /* =========================== 卡尔曼滤波器测量值更新 =========================== */

            Speed_EstimateKF->MeasuredVector[0] = vel;
            Speed_EstimateKF->MeasuredVector[1] = acc;

        /* =========================== 卡尔曼滤波器更新 =========================== */

            Kalman_Filter_Update(Speed_EstimateKF);

        /* =========================== 设置为机体x' =========================== */

            leg->state_variable_feedback.x_dot = Speed_EstimateKF->FilteredValue[0];

    }
```

```chassis_task.c

```

## 定义

    研究对象：轮毂电机转子，机体

    c系：轮毂电机定子

    b系：机体

    e系：大地

## 1. 角速度

###### 1.1 获取初始角速度

    由电机编码器反馈，可得：    轮毂电机转子相对于轮毂电机定子（c系）的角速度为$w_{ecd}$（注意<mark>根据机械结构加负号</mark>）

    由运动学解算，可得：轮毂电机定子（c系） 相对于 机体（b系） 的角速度为$\phi_0'$

    由IMU测量，可得：机体（b系）相对于大地（e系）的角速度为$w_{eb}$

###### 1.2 计算

     轮毂电机转子 相对于 大地（e系） 的角速度$\omega=w_{ecd}+\phi_0'+w_{eb}$

## 2. 速度

###### 2.1 假设轮毂与地面不存在打滑，可得：

轮毂电机转子相对于大地（e系） 的平动速度$x'=\omega R$

其中R为驱动轮半径

###### 2.2 通过$x'$计算机体相对于大地的速度$x_O'$

同侧两关节电机连线中点$O$的位移$x_O=x+L_0sin\theta$（注意与机体质心位移X_M作区分）

可得：$x_O'=x'+L_0\theta cos\theta+L_0'sin\theta$

其中$L_0$为腿长（注意要作为变量计算），$\theta$为$L_0$与竖直方向夹角

###### 2.3 取平均计算机体速度$\bar{x'}$

左腿计算出$X_{Ol}'$，右腿计算出$X_{Or}'$，取平均，可得：

$\bar{x'}= \frac{X_{Ol}'+X_{Or}'}{2}$

> 可参考第二篇文章中对于VMC与LQR相关量的定义和图示

###### 2.4 通过卡尔曼滤波估计$x'$，以防轮毂打滑

    模型同上述卡尔曼滤波器，特殊点是力$F$为0，即$X_k^-=AX_{k-1}^+$

    同理，可用卡尔曼滤波器估计$\theta,\theta'$

> 参考文章：
> 
> 1. [图说卡尔曼滤波，一份通俗易懂的教程 - 论智的文章 - 知乎](https://zhuanlan.zhihu.com/p/39912633)
> 
> 2. [从全状态观测器到卡尔曼滤波器（四） - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/339325456)（系列）
> 
> 3.  [轮腿倒立摆机器人运动速度估计 - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/689921165)
