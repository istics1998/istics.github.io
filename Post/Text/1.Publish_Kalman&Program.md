> 编者：
> 
>     SZTU悍匠平步电控
> 
> 
> 
> 整体思路：
> 
>     将轮毂电机反馈的角速度映射到大地系，计算出机体速度
> 
>     ，再将$\begin{bmatrix}x' \\x'' \end{bmatrix}$通过卡尔曼滤波融合，以获得$x'$的最佳估计
> 
> 
> 
> 目录：
> 
> |
> 
> ——卡尔曼滤波
> 
>         |
> 
>         ——代码
> 
>         ——预测
> 
>         ——更新
> 
>         ——反馈
> 
> |
> 
> ——速度解算
> 
>         |
> 
>         ——Clion代码
> 
>         ——定义
> 
>         ——角速度
> 
>         —速度
> 
>         ——估计$x'$
> 
> |
> 
> ——参考文章
> 
> 
> 
> <mark>套用只需按实际情况改变高亮部分数据</mark>

# 卡尔曼滤波：让估计的状态尽可能接近真实值

## 代码：

> ```kalman_filter.c
> 
> /* =========================== 执行卡尔曼滤波 ============================= */
> 
>     float *Kalman_Filter_Update(KalmanFilter_t *kf)
>     {
> 
>         /* =========================== 1.1 获取量测信息 ============================= */
> 
>             Kalman_Filter_Measure(kf);
> 
>         /* =========================== 1.2 先验估计 X_prev(k) = A·X_pred(k-1)+ B·u ============================= */
> 
>             Kalman_Filter_xhatMinusUpdate(kf);
> 
>         /* =========================== 2. 预测更新 P_prev(k) = A·P_pred(k-1)·A^T + Q ============================= */
> 
>             Kalman_Filter_PminusUpdate(kf);
> 
>             /* =========================== 量测有效,更新 ============================= */
> 
>                 if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0)
>                 {
> 
>                     /* =========================== 2. 量测更新 K(k) = P_prev(k)·H^T / (H·P_prev(k)·H^T + R) ============================= */
> 
>                         Kalman_Filter_SetK(kf);
> 
>                     /* =========================== 2. 融合 X_pred(k) = X_prev(k) + K(k)·(z(k) - H·X_prev(k)) ============================= */
> 
>                         Kalman_Filter_xhatUpdate(kf);
> 
>                     /* =========================== 2. 修正方差 P_pred(k) = (I-K(k)·H)·P_prev(k) ============================= */
> 
>                         Kalman_Filter_P_Update(kf);
>                 }
> 
>         /* =========================== 量测无效,仅预测 ============================= */
> 
>             else
>             {
> 
>                 /* =========================== X_pred(k) = X_prev(k) ============================= */
> 
>                     memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
> 
>                 /* =========================== P_pred(k) = P_prev(k) ============================= */
> 
>                     memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
>             }
> 
>         /* =========================== 避免滤波器过度收敛 ============================= */
> 
>             for (uint8_t i = 0; i < kf->xhatSize; i++)
>             {
>                 if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i])
>                     kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
>             }
> 
>         /* =========================== X = X_pred 并返回 ============================= */
> 
>             memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
>             return kf->FilteredValue;
>     }
> 
> ```

## 1.预测：根据$k-1$时刻状态预测$k$时刻状态

![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\Kalman.png)

#### 1.1 质量为m的机器人匀速自由运动

定义机器人的状态为$X$，由于状态$X$与位置$x$和速度$x'$有关，定义状态$X=\begin{bmatrix}x \\x' \end{bmatrix} $

x和x'存在关系，将x和x'的关系，用协方差矩阵表示，可得：不确定性$P=\begin{bmatrix}\sum_{xx} \sum_{xx'} \\\sum_{x'x} \sum_{x'x'} \end{bmatrix}$

> $i$和$j$间的关系可用协方差矩阵$\sum_{ij}$表示
> 
> 矩阵$i,j$位置的元素是第$i$个变量和第$j$个变量之间的相关程度(协方差)

根据运动学，可得：$x_k=x_{k-1}+\Delta t x'_{k-1},x'_k=x'_{k-1}$

令$X_k^-=AX_{k-1}^+$，可得：<mark>$A=\begin{bmatrix}1&\Delta t\\0&1\end{bmatrix}$</mark>(有时也用$F$表示，此处为不与力$F$混淆，使用$A$)

令$P_k^-=AP_{k-1}^+A^T$

> $Cov(x)=\sum$，则$Cov(Ax)=A\sum A^T$

#### 1.2 外部给该机器人力$F$，沿机器人运动正方向，并考虑外部不可控扰动Q

根据运动学，可得：$x_k=x_{k-1}+\Delta t x'_{k-1}+\frac{1}{2}\frac{F}{m}\Delta t^2,x'_k=x'_{k-1}+\frac{F}{m}\Delta t,x_k''=\frac{F}{m}$

令$u=\begin{bmatrix}F\end{bmatrix}$，$X_k^-=AX_{k-1}^++Bu_{k-1}$，可得：$B=\begin{bmatrix}\frac{\Delta t^2}{2m}\\ \frac{\Delta t}{m}\end{bmatrix}$

令$P_k^-=AP_{k-1}^+A^T+\Gamma Q \Gamma^T$，其中， $\Gamma$一般为单位阵$I$

## 2. 更新：融合预测值$X_k^-$与$k$时刻传感器测量值$z_k$

令$X_k^+=X_k^-+K_k(z_k-HX_k^-)$，即最终估计的系统当前状态

令$P_k^+=\Gamma P_k^- -K_kHP_k^-$，即估计状态的不确定性

其中卡尔曼增益$K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}$，$H$一般为单位阵$I$

<mark>$Q,R$需根据实际调整</mark> ，相信测量值则调小$R$，相信预测值则调小$Q$

## 3.反馈：

$X_k^+,P_k^+$进入下一轮卡尔曼滤波

经过多轮滤波，不确定性$P$越来越小，即实现状态$X$尽可能接近真实值

> <区分>控制器：根据目标值与$X_k^+$的差值计算力$F$,作为$u$输入系统，使系统趋于目标值

# 速度解算

## Clion代码

```speed_kalman_filter.c

/* =========================== 2.4 x x'融合卡尔曼滤波更新 =========================== */

    static void Speed_EstimateKF_Update(KalmanFilter_t *Speed_EstimateKF, float vel, float acc)
    {

        /* =========================== 卡尔曼滤波器测量值更新 =========================== */

            Speed_EstimateKF->MeasuredVector[0] = vel;
            Speed_EstimateKF->MeasuredVector[1] = acc;

        /* =========================== 卡尔曼滤波器更新 =========================== */

            Kalman_Filter_Update(Speed_EstimateKF);

        /* =========================== 提取估计值 =========================== */

            vel_acc[0] = Speed_EstimateKF->FilteredValue[0];
            vel_acc[1] = Speed_EstimateKF->FilteredValue[1];
    }

/* =========================== 速度解算 =========================== */

    void speed_calc(void)
    {

        /* =========================== c系：轮毂电机定子 b系：机体 e系：大地 =========================== */

        /* =========================== 1. 角速度 =========================== */

            /* =========================== 1.1 电机编码器反馈角速度 （c系 转子相对定子）  =========================== */
        
                float w_ecd_l = - get_wheel_motors()->speed_rpm / RATIO * RPM_TO_RAD_PER_S;
                float w_ecd_r = (get_wheel_motors() + 1)->speed_rpm / RATIO * RPM_TO_RAD_PER_S ;
        
            /* =========================== 1.1 根据机械结构加负号 =========================== */

                w_ecd_l = - w_ecd_l;
                w_ecd_r = w_ecd_r;

            /* =========================== 1.1 定子角速度 （c系相对于b系） =========================== */

                float phi_bc_dot_l = chassis.leg_L.vmc.forward_kinematics.fk_phi.d_phi0;
                float phi_bc_dot_r = chassis.leg_R.vmc.forward_kinematics.fk_phi.d_phi0;

            /* =========================== 1.1 IMU测得机体角速度 （b系相对于e系） =========================== */

                float w_eb_l = - chassis.imu_reference.pitch_gyro;
                float w_eb_r = - chassis.imu_reference.pitch_gyro;

            /* =========================== 1.2 轮毂（c系）相对大地（e系）的角速度 =========================== */

                float w_l =  w_ecd_l + phi_bc_dot_l +w_eb_l;
                float w_r = w_ecd_r + phi_bc_dot_r + w_eb_r;

        /* =========================== 2. 速度 =========================== */

            /* =========================== 2.1 轮毂速度 =========================== */

                float v_l = w_l * chassis_physical_config.wheel_radius;
                float v_r = w_r * chassis_physical_config.wheel_radius;

            /* =========================== 2.2 两个机体速度 =========================== */

                float v_lb = v_l
                    + chassis.leg_L.vmc.forward_kinematics.fk_L0.L0 * chassis.leg_L.state_variable_feedback.theta_dot * cosf(chassis.leg_L.state_variable_feedback.theta)
                    + chassis.leg_L.vmc.forward_kinematics.fk_L0.L0_dot * sinf(chassis.leg_L.state_variable_feedback.theta);

                float v_rb = v_r
                    + chassis.leg_R.vmc.forward_kinematics.fk_L0.L0 * chassis.leg_R.state_variable_feedback.theta_dot * cosf(chassis.leg_R.state_variable_feedback.theta)
                    + chassis.leg_R.vmc.forward_kinematics.fk_L0.L0_dot * sinf(chassis.leg_R.state_variable_feedback.theta);

            /* =========================== 2.3 取平均计算出机体速度 =========================== */

                float x_dot = (v_lb + v_rb) / 2;

        /* =========================== x x' x'' =========================== */

            /* =========================== 上次的x' =========================== */

                chassis.leg_L.state_variable_feedback.x_dot_last = chassis.leg_L.state_variable_feedback.x_dot;
                chassis.leg_R.state_variable_feedback.x_dot_last = chassis.leg_R.state_variable_feedback.x_dot;

            /* =========================== 2.4 x x'融合卡尔曼滤波更新 =========================== */

                Speed_EstimateKF_Update(&Speed_EstimateKF, x_dot, chassis.imu_reference.robot_ax);

            /* =========================== x' =========================== */

                chassis.leg_L.state_variable_feedback.x_dot = vel_acc[0];
                chassis.leg_R.state_variable_feedback.x_dot = vel_acc[0];

            /* =========================== x =========================== */

                /* =========================== 如果在遥控 不设置x =========================== */

                    if (chassis.chassis_ctrl_info.v_m_per_s != 0.0f)
                    {
                        chassis.leg_L.state_variable_feedback.x = 0.0f;
                        chassis.leg_R.state_variable_feedback.x = 0.0f;
                    }

                /* =========================== 否则 求积分得到x =========================== */

                    else
                    {
                        chassis.leg_L.state_variable_feedback.x +=
                                (CHASSIS_PERIOD * 0.001f) * chassis.leg_L.state_variable_feedback.x_dot;
                        chassis.leg_R.state_variable_feedback.x +=
                                (CHASSIS_PERIOD * 0.001f) * chassis.leg_R.state_variable_feedback.x_dot;
                    }

            /* =========================== x'' =========================== */

                chassis.leg_L.state_variable_feedback.x_ddot =
                        (chassis.leg_L.state_variable_feedback.x_dot - chassis.leg_L.state_variable_feedback.x_dot_last)
                        /(CHASSIS_PERIOD * 0.001f);

                chassis.leg_R.state_variable_feedback.x_ddot =
                        (chassis.leg_R.state_variable_feedback.x_dot - chassis.leg_R.state_variable_feedback.x_dot_last)
                        /(CHASSIS_PERIOD * 0.001f);

    }
```

## 定义

    研究对象：轮毂电机转子，机体

    c系：轮毂电机定子

    b系：机体

    e系：大地

## 1. 角速度

###### 1.1 获取初始角速度

    由电机编码器反馈，可得：    轮毂电机转子 相对于 轮毂电机定子（c系） 的角速度为$w_{ecd}$（注意<mark>根据机械结构加负号</mark>）

    由运动学解算，可得：                                  轮毂电机定子（c系） 相对于 机体（b系） 的角速度为$\phi_0'$

    由IMU测量，可得：                 机体（b系） 相对于 大地（e系） 的角速度为$w_{eb}$

###### 1.2 计算

     轮毂电机转子 相对于 大地（e系） 的角速度$\omega=w_{ecd}+\phi_0'+w_{eb}$

## 2. 速度

###### 2.1 假设轮毂与地面不存在打滑，可得：

轮毂电机转子相对于大地（e系） 的平动速度$x'=\omega R$

其中R为驱动轮半径

###### 2.2 通过$x'$计算机体相对于大地的速度$x_O'$

同侧两关节电机连线中点$O$的位移$x_O=x+L_0sin\theta$（注意与机体质心位移X_M作区分）

可得：$x_O'=x'+L_0\theta cos\theta+L_0'sin\theta$

其中$L_0$为腿长（注意要作为变量计算），$\theta$为$L_0$与竖直方向夹角

###### 2.3 取平均计算机体速度$\bar{x'}$

左腿计算出$X_{Ol}'$，右腿计算出$X_{Or}'$，取平均，可得：

$\bar{x'}= \frac{X_{Ol}'+X_{Or}'}{2}$

> 可参考第二篇文章中对于VMC与LQR相关量的定义和图示

###### 2.4 估计$x'$

    模型同上述卡尔曼滤波观测器，特殊点是力$F$为0，即$X_k^-=AX_{k-1}^+$

> 参考文章：
> 
> 1. [图说卡尔曼滤波，一份通俗易懂的教程 - 论智的文章 - 知乎](https://zhuanlan.zhihu.com/p/39912633)
> 
> 2. [从全状态观测器到卡尔曼滤波器（四） - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/339325456)（系列）
> 
> 3.  [轮腿倒立摆机器人运动速度估计 - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/689921165)
