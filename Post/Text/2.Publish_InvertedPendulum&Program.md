> 编者： 
> 
>     SZTU悍匠平步电控
> 
> 参考文章：
> 
> 1. [RoboMaster平衡步兵机器人控制系统设计 - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/563048952)
> 
> 2. [五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)
> 
> 3. [两轮自平衡机器人LQR-模糊控制算法研究 - 道客巴巴](https://www.doc88.com/p-45329024185491.html?r=1)
> 
> 4. [[RM2025 平衡步兵电控开源]山海机甲战队完整形态技术文档软件设计开源-RoboMaster 社区](https://bbs.robomaster.com/article/696393?source=8)

# 

# 五连杆 VMC

## Clion代码

```robot_def.c
/* =========================== 1.1 机械量 =========================== */

ChassisPhysicalConfig chassis_physical_config = {

        .wheel_radius = 0.06f,
        .body_weight = 11.255f, // 纯底盘
        // .body_weight = 11.255f +2.494f, // 加云台
        .wheel_weight = 0.553f,
        .l1 = 0.1785f,
        .l2 = 0.2125f,
        .l3 = 0.2125f,
        .l4 = 0.1785f,
        .l5 = 0.0f,
};
```

```vmc.c
/* ========================= 1.2 phi1 phi4 phi1',phi4'========================= */

void vmc_phi_update(Leg *leg_L, Leg *leg_R) 
{

    /* ========================= 1.2.1 初始phi1 phi4 ========================= */

    float LF_joint_pos = (get_joint_motors() + 0)->pos_r;
    float LB_joint_pos = (get_joint_motors() + 1)->pos_r;
    float RF_joint_pos = (get_joint_motors() + 2)->pos_r;
    float RB_joint_pos = (get_joint_motors() + 3)->pos_r;

    /* ========================= 1.2.2 实际phi1 phi4 ========================= */

    leg_L->vmc.forward_kinematics.fk_phi.phi1 = LF_joint_pos + PHI1_OFFSET;
    leg_L->vmc.forward_kinematics.fk_phi.phi4 = LB_joint_pos + PHI4_OFFSET;
    leg_R->vmc.forward_kinematics.fk_phi.phi1 = -RF_joint_pos + PHI1_OFFSET;
    leg_R->vmc.forward_kinematics.fk_phi.phi4 = -RB_joint_pos + PHI4_OFFSET;

    /* ========================= 1.2.1 初始phi1' phi4' ========================= */

    float LF_joint_speed = (get_joint_motors() + 0)->angular_vel;
    float LB_joint_speed = (get_joint_motors() + 1)->angular_vel;
    float RF_joint_speed = (get_joint_motors() + 2)->angular_vel;
    float RB_joint_speed = (get_joint_motors() + 3)->angular_vel;

    /* ========================= 1.2.2 实际phi1' phi4' ========================= */

    leg_L->vmc.forward_kinematics.fk_phi.phi1_dot = LF_joint_speed;
    leg_L->vmc.forward_kinematics.fk_phi.phi4_dot = LB_joint_speed;
    leg_R->vmc.forward_kinematics.fk_phi.phi1_dot = -RF_joint_speed;
    leg_R->vmc.forward_kinematics.fk_phi.phi4_dot = -RB_joint_speed;

}

/* =========================== 1.3-1.6 正解算 =========================== */

static void forward_kinematics(Leg *leg, ChassisPhysicalConfig *physical_config)
{

    /* =========================== 中间变量 =========================== */

    float temp=0,temp_y=0,temp_x=0;

    /* =========================== 1.3  B,D坐标 =========================== */

    leg->vmc.forward_kinematics.fk_point_coordinates.b_x = 
        physical_config->l1 * cosf(leg->vmc.forward_kinematics.fk_phi.phi1);
    leg->vmc.forward_kinematics.fk_point_coordinates.b_y = 
        physical_config->l1 * sinf(leg->vmc.forward_kinematics.fk_phi.phi1);
    leg->vmc.forward_kinematics.fk_point_coordinates.d_x = 
        physical_config->l5 + physical_config->l4 * cosf(leg->vmc.forward_kinematics.fk_phi.phi4);
    leg->vmc.forward_kinematics.fk_point_coordinates.d_y = 
        physical_config->l4 * sinf(leg->vmc.forward_kinematics.fk_phi.phi4);

    /* =========================== 1.4  lBD^2  =========================== */

    float L_BD_sq =  
        (leg->vmc.forward_kinematics.fk_point_coordinates.d_x - leg->vmc.forward_kinematics.fk_point_coordinates.b_x) 
        * (leg->vmc.forward_kinematics.fk_point_coordinates.d_x - leg->vmc.forward_kinematics.fk_point_coordinates.b_x)
        + (leg->vmc.forward_kinematics.fk_point_coordinates.d_y - leg->vmc.forward_kinematics.fk_point_coordinates.b_y) 
        * (leg->vmc.forward_kinematics.fk_point_coordinates.d_y - leg->vmc.forward_kinematics.fk_point_coordinates.b_y);

    /* =========================== 1.5  phi2 =========================== */

    float L_A0 = 2.0f * physical_config->l2 
        * (leg->vmc.forward_kinematics.fk_point_coordinates.d_x - leg->vmc.forward_kinematics.fk_point_coordinates.b_x);
    float L_B0 = 2.0f * physical_config->l2 
        * (leg->vmc.forward_kinematics.fk_point_coordinates.d_y - leg->vmc.forward_kinematics.fk_point_coordinates.b_y);
    float L_C0 = physical_config->l2 
        * physical_config->l2 + L_BD_sq - physical_config->l3 * physical_config->l3;
    temp = L_A0 * L_A0 + L_B0 * L_B0 - L_C0 * L_C0;
    temp_y = L_B0 + sqrtf(ABS(temp));
    temp_x = L_A0 + L_C0;
    leg->vmc.forward_kinematics.fk_phi.phi2 = 2.0f * atan2f(temp_y, temp_x);

    /* =========================== 1.6  xC,yC =========================== */

    leg->vmc.forward_kinematics.fk_point_coordinates.c_x = 
        physical_config->l1 * cosf(leg->vmc.forward_kinematics.fk_phi.phi1) 
        + physical_config->l2 * cosf(leg->vmc.forward_kinematics.fk_phi.phi2);
    leg->vmc.forward_kinematics.fk_point_coordinates.c_y = 
        physical_config->l1 * sinf(leg->vmc.forward_kinematics.fk_phi.phi1) 
        + physical_config->l2 * sinf(leg->vmc.forward_kinematics.fk_phi.phi2);

    /* =========================== 1.7 phi3 =========================== */

    temp_y = 
        leg->vmc.forward_kinematics.fk_point_coordinates.c_y 
        - leg->vmc.forward_kinematics.fk_point_coordinates.d_y;
    temp_x = 
        leg->vmc.forward_kinematics.fk_point_coordinates.c_x 
        - leg->vmc.forward_kinematics.fk_point_coordinates.d_x;
    leg->vmc.forward_kinematics.fk_phi.phi3 = atan2f(temp_y, temp_x);

    /* =========================== 1.8  L0 =========================== */

    temp =  
        (leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f) 
        * (leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f)
        + leg->vmc.forward_kinematics.fk_point_coordinates.c_y 
        * leg->vmc.forward_kinematics.fk_point_coordinates.c_y;
    leg->vmc.forward_kinematics.fk_L0.L0 = sqrtf(ABS(temp));

    /* =========================== 1.8  phi0 =========================== */

    temp_y = leg->vmc.forward_kinematics.fk_point_coordinates.c_y;
    temp_x = leg->vmc.forward_kinematics.fk_point_coordinates.c_x - physical_config->l5 * 0.5f;
    leg->vmc.forward_kinematics.fk_phi.phi0 = atan2f(temp_y, temp_x);

}

/* =========================== 1. 正解算 =========================== */

void vmc_calc(void)
{

    /* ========================= 1.2 phi1 phi4 phi1',phi4'========================= */

    vmc_phi_update(&chassis.leg_L, &chassis.leg_R);

    /* =========================== 1.3-1.6 正解算 =========================== */

    forward_kinematics(&chassis.leg_L, &chassis_physical_config);
    forward_kinematics(&chassis.leg_R, &chassis_physical_config);

    /* =========================== 腿部协调处理 =========================== */

    leg_coordinate_handle();
}


/* =========================== 2. 正动力学变换 =========================== */

void vmc_forward_dynamics(VMC *vmc, const ChassisPhysicalConfig *physical_config) 
{

    /* =========================== 矩阵 =========================== */

    vmc->forward_kinematics.J_F_to_T.E.x1_1 =
            physical_config->l1 * cosf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi3)
         * sinf(vmc->forward_kinematics.fk_phi.phi1 - vmc->forward_kinematics.fk_phi.phi2)
            / (vmc->forward_kinematics.fk_L0.L0
        * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2));

    vmc->forward_kinematics.J_F_to_T.E.x1_2 =
            physical_config->l1 * sinf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi3)
            * sinf(vmc->forward_kinematics.fk_phi.phi1 - vmc->forward_kinematics.fk_phi.phi2)
            / sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2);

    vmc->forward_kinematics.J_F_to_T.E.x2_1 =
            physical_config->l4 * cosf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi2)
            * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi4)
            / (vmc->forward_kinematics.fk_L0.L0
            * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2));

    vmc->forward_kinematics.J_F_to_T.E.x2_2 =
            physical_config->l4 * sinf(vmc->forward_kinematics.fk_phi.phi0 - vmc->forward_kinematics.fk_phi.phi2)
            * sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi4)
            / sinf(vmc->forward_kinematics.fk_phi.phi3 - vmc->forward_kinematics.fk_phi.phi2);

    /* =========================== T1,T4 =========================== */

    Matrix_multiply(2, 2, vmc->forward_kinematics.J_F_to_T.array,
                    2, 1, vmc->forward_kinematics.Fxy_set_point.array,
                    vmc->forward_kinematics.T1_T4_set_point.array);
}
```

## 定义如下图：

![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\InvertedPendulum-VMC.jpg)

| 力/力矩  | 含义     | 方向                   | 单位    |
| ----- | ------ | -------------------- | ----- |
| $F$   | 关节力    | 沿$L_0$               | $N$   |
| $T_p$ | 关节等效力矩 | 垂直于$L_0$，右手螺旋向外(逆时针) | $N·m$ |
| $T_1$ | 前关节力矩  | 右手螺旋向外(逆时针)          | $N·m$ |
| $T_4$ | 后关节力矩  | 右手螺旋向外(逆时针)          | $N·m$ |

## 1. 正解算：得到腿长$L_0$

###### 1.1 <mark>机械给定$l_1,l_2,l_3,l_4,l_5$</mark>（对于串联腿，$l_5=0$）

###### 1.2 获取$\phi_1,\phi_4,\phi1',\phi4'$

###### 1.2.1 关节电机编码器读取初始$\phi_1,\phi_4,\phi1',\phi4'$

###### 1.2.2 <mark>根据机械装配得到实际$\phi_1,\phi_4,\phi1',\phi4'$</mark>

###### 1.3 由图中可得$B,D$坐标：

            $B(x_B,y_B):x_B=l_1cos\phi_1, y_B=l_1sin\phi_1$

            $D(x_D,y_D):x_D=l_5+l_4cos\phi_4, y_D=l_4sin\phi_4$

###### 1.4 用$B(x_B,y_B)$和$D(x_D,y_D)$ 表示$l_{BD}^2$ ，并分别表示$C(x_C,y_C)$，可得：

            $l_{BD}^2=(x_D-x_B)^2+(y_D-y_B)^2$……1.4.1

            $x_C=x_B+l_2cos\phi_2=x_D+l_3cos\phi_3$……1.4.2

            $y_C=y_B+l_2sin\phi_2=y_D+l_3sin\phi_3$……1.4.3

###### 1.5 由1.4.1&1.4.2&1.4.3计算（推导见[五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)），可得：

            $\phi_2=2arctan(\frac{B_0+\sqrt{A_0^2+B_0^2-C_0^2}}{A_0+C_0})$……1.5.1

            其中$A_0=2l_2(x_D-x_B),B_0=2l_2(y_D-y_B),C_0=l_2^2+l_{BD}^2-l_3^2$

###### 1.6 由1.5.1&1.4.2&1.4.3,可得$C(x_C,y_C)$：

            $x_C=x_B+l_2cos\phi_2$

            $y_C=y_B+l_2sin\phi_2$

###### 1.7 构造$Rt\Delta CO_1D$,可得：

            $\phi_3=arctan(\frac{y_C-y_D}{x_C-x_D})$

###### 1.8 构造$Rt\Delta CO_2O$，可得：

        $L_0=\sqrt{(x_C-\frac{l_5}{2})^2+y_C^2}$

        $\phi_0=arctan(\frac{y_C}{x_C-\frac{l_5}{2}})$

## 2. 正动力学变换：得到关节力矩$\begin{bmatrix} T_1\\T_4 \end{bmatrix}$

###### 经计算（推导见[五连杆运动学解算与VMC - 韭菜的菜的文章 - 知乎](https://zhuanlan.zhihu.com/p/613007726)），可得：

        $\begin{bmatrix} T_1\\T_4 \end{bmatrix}=\begin{bmatrix} \frac{l_1cos(\phi_0-\phi_3)sin(\phi_1-\phi_2)}{L_0sin(\phi_3-\phi_2)}&\frac{l_1sin(\phi_0-\phi_3)sin(\phi_1-\phi_2)}{sin(\phi_3-\phi_2)}\\ \frac{l_4cos(\phi_0-\phi_2)sin(\phi_3-\phi_4)}{L_0sin(\phi_3-\phi_2)} & \frac{l_4sin(\phi_0-\phi_2)sin(\phi_3-\phi_4)}{sin(\phi_3-\phi_2)}\end{bmatrix}\begin{bmatrix} T_p\\F \end{bmatrix}$

# LQR 控制系统

## Matlab代码

```get_k_length.m
function K = get_k_length(leg_length, dt)

    % ============================= 1.1 机械量 ============================= %

    R = 0.06;               % 轮毂半径
    l = 0.02363;            % 机体重心到机体转轴的距离
    % B_L = 0.554;          % 机体长度（x方向）
    % B_H = 0.167;          % 机体高度（z方向）

    m_w = 0.167;            % 轮毂质量（不含轮毂电机）
    m_p = 1.865;            % 摆杆质量（含轮毂电机不含关节电机）
    M = 11.255;             % 机体质量（含关节电机 纯底盘）
    % M = 11.255 + 2.494;   % 机体质量（含关节电机 加云台）

    g = 9.8;                % 重力加速度

    % ============================= 1.2 距离 ============================= %

    %此处理想化
    L = leg_length/2;                               % 摆杆重心到轮毂轴线的距离
    L_M = leg_length/2;                             % 摆杆重心到机体转轴的距离

    % ============================= 1.2 转动惯量 ============================= %

    I_w = 0.000418255;                              % 轮毂转子的转动惯量 (1/2)*m_w*R^2 
    I_M = 0.407431240;                              % 机体绕质心的转动惯量（x轴） (1/12)*M*(B_L^2+B_H^2) 
    I_p = (1/12) * m_p * ((L + L_M)^2 + 0.05^2);    % 摆杆绕质心的转动惯量

    % ===================== 1.6 M矩阵 (1.3-1.5为推导) ===================== %

    M11 = I_p + m_p*L^2 + M*(L + L_M)^2;
    M12 = (m_p + M)*L + M*L_M;
    M13 = -M*l*(L + L_M);

    M21 = m_p*L*R + M*R*(L + L_M);
    M22 = I_w/R + R*(m_w + m_p + M);
    M23 = -R*M*l;

    M31 = -M*l*(L + L_M);
    M32 = -M*l;
    M33 = I_M + M*l^2;

    M_mat = [ M11,  M12,  M13 ;
              M21,  M22,  M23 ;
              M31,  M32,  M33 ];

    % ============================= 1.6 Z矩阵 ============================= %

    Z11 = (m_p + M)*g*L + M*g*L_M;
    Z32 = M*g*l;

    Z_mat = [ Z11,    0,   -1,    1 ;
                0,    0,    1,    0 ;
                0,  Z32,    0,    1 ];

    % ============================= 1.7 G矩阵 ============================= %

    G = M_mat \ Z_mat;

    % ============================= 1.9 A矩阵 ============================= %

    A_mat = [      0,       1,       0,       0,       0,       0 ;
              G(1,1),       0,       0,       0,  G(1,2),       0 ;
                   0,       0,       0,       1,       0,       0 ;
              G(2,1),       0,       0,       0,  G(2,2),       0 ;
                   0,       0,       0,       0,       0,       1 ;
              G(3,1),       0,       0,       0,  G(3,2),       0 ];

    % ============================= 1.8 B矩阵 ============================= %

    B_mat = [      0,        0 ;
              G(1,3),   G(1,4) ;
                   0,       0 ;
              G(2,3),   G(2,4) ;
                   0,        0 ;
              G(3,3),   G(3,4) ];

    % ============================= 2.1 Q矩阵 ============================= %

    % 根据实际情况，设定Q
    % 权重顺序: θ, θ', x, x', φ, φ'
    Q_mat = diag([1, 1, 400, 1, 1, 1]);

    % ============================= 2.1 R矩阵 ============================= %

    %根据实际情况，设定R
    % 权重顺序: 轮毂 关节
    R_mat = diag([1, 0.25]);

    % ============================= 2.2 K矩阵 ============================= %

    K = lqrd(A_mat, B_mat, Q_mat, R_mat, dt);


end
```

```get_k.m
tic

% ============================= 3.1 考虑不同腿长 ============================= %

% 根据机械结构设定最小&最大腿长 此处为100mm~400mm 步长10mm
leg=0.1:0.01:0.4;

% 根据控制频率设置dt 此处为0.002
dt = 0.002;

% 遍历每个腿长值
for j = 1:length(leg)

    % 计算当前腿长下的K
    k = get_k_length(leg(j), dt);

    % 提取K第一行元素
    k11(j) = k(1,1); k12(j) = k(1,2); k13(j) = k(1,3);
    k14(j) = k(1,4); k15(j) = k(1,5); k16(j) = k(1,6);

    % 提取K第二行元素
    k21(j) = k(2,1); k22(j) = k(2,2); k23(j) = k(2,3);
    k24(j) = k(2,4); k25(j) = k(2,5); k26(j) = k(2,6);

end

% ============================= 3.1 多项式拟合 ============================= %

a11=polyfit(leg,k11,3); 
a12=polyfit(leg,k12,3);
a13=polyfit(leg,k13,3);
a14=polyfit(leg,k14,3);
a15=polyfit(leg,k15,3);
a16=polyfit(leg,k16,3);

a21=polyfit(leg,k21,3);
a22=polyfit(leg,k22,3);
a23=polyfit(leg,k23,3);
a24=polyfit(leg,k24,3);
a25=polyfit(leg,k25,3);
a26=polyfit(leg,k26,3);

% ============================= 打印K ============================= %

fprintf('float wheel_fitting_factor[6][4] = \n { \n');
fprintf('{%ff,%ff,%ff,%ff},\n', a11);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a12);
fprintf('{%ff,%ff,%ff,%ff},\n', a13);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a14);
fprintf('{%ff,%ff,%ff,%ff},\n', a15);
fprintf('{%ff,%ff,%ff,%ff}\n', a16);
fprintf('};\n\n');

fprintf('float joint_fitting_factor[6][4] = \n { \n');
fprintf('{%ff,%ff,%ff,%ff},\n', a21);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a22);
fprintf('{%ff,%ff,%ff,%ff},\n', a23);
fprintf('{%ff,%ff,%ff,%ff},\n\n', a24);
fprintf('{%ff,%ff,%ff,%ff},\n', a25);
fprintf('{%ff,%ff,%ff,%ff}\n', a26);
fprintf('};\n\n');

toc
```

## Clion代码

```lqr.c
/*============================= 复制matlab打印的K到这里 =============================*/

float wheel_fitting_factor[6][4] = 
{
        {-106.056581f,159.355772f,-141.368843f,-2.497662f},
        {-2.792894f,-0.170942f,-18.165510f,-0.723776f},

        {-23.449645f,33.965494f,-15.113625f,-17.884783f},
        {61.129256f,-52.262961f,9.776284f,-15.028712f},

        {-265.217762f,437.342910f,-280.669103f,82.143956f},
        {-28.725081f,34.307545f,-16.219390f,8.486958f}
};

float joint_fitting_factor[6][4] = 
{
        {594.109619f,-607.207050f,198.483898f,7.456326f},
        {54.937773f,-53.808518f,5.965132f,2.239702f},

        {128.383033f,-25.220491f,-58.933135f,18.018646f},
        {-68.775434f,129.858795f,-87.505969f,17.217716f},

        {1351.795472f,-1533.134904f,629.654032f,66.086358f},
        {81.044378f,-106.303704f,53.882941f,-0.885932f}
};

/*============================= 3.1 不同腿长下进行多项式拟合 =============================*/
void chassis_K_matrix_fitting(float L0, float K[6], const float KL[6][4]) 
{
    for (int i = 0; i < 6; i++)
    {
        K[i] = KL[i][0] * powf(L0, 3) + KL[i][1] * powf(L0, 2) + KL[i][2] * powf(L0, 1) + KL[i][3] * powf(L0, 0);
    }
}
```

```chassis_task.c
/* ============================= 4. 计算力矩 轮毂 ============================= */

static void wheel_calc(void)
{

    /* ============================= 3.1 不同腿长下进行多项式拟合 ============================= */

    chassis_K_matrix_fitting(chassis.leg_L.vmc.forward_kinematics.fk_L0.L0, wheel_K_L, wheel_fitting_factor);
    chassis_K_matrix_fitting(chassis.leg_R.vmc.forward_kinematics.fk_L0.L0, wheel_K_R, wheel_fitting_factor);

    /* ============================= 3.2 加入目标输入 ============================= */

    chassis.leg_L.wheel_torque =
      wheel_K_L[0] * (chassis.leg_L.state_variable_feedback.theta - 0.0f)
      + wheel_K_L[1] * (chassis.leg_L.state_variable_feedback.theta_dot - 0.0f)
      + wheel_K_L[2] * (chassis.leg_L.state_variable_feedback.x - 0.0f)
      + wheel_K_L[3] * (chassis.leg_L.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
      + wheel_K_L[4] * (chassis.leg_L.state_variable_feedback.phi - 0.0f)
      + wheel_K_L[5] * (chassis.leg_L.state_variable_feedback.phi_dot - 0.0f);

    chassis.leg_R.wheel_torque =  
        wheel_K_R[0] * (chassis.leg_R.state_variable_feedback.theta - 0.0f)
        + wheel_K_R[1] * (chassis.leg_R.state_variable_feedback.theta_dot - 0.0f)
        + wheel_K_R[2] * (chassis.leg_R.state_variable_feedback.x - 0.0f)
        + wheel_K_R[3] * (chassis.leg_R.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
        + wheel_K_R[4] * (chassis.leg_R.state_variable_feedback.phi - 0.0f)
        + wheel_K_R[5] * (chassis.leg_R.state_variable_feedback.phi_dot - 0.0f);

    /* ============================= 4.2 根据机械结构加负号 ============================= */

    chassis.leg_R.wheel_torque *= -1;

    /* ============================= 限幅 ============================= */

    VAL_LIMIT(chassis.leg_L.wheel_torque, MIN_WHEEL_TORQUE, MAX_WHEEL_TORQUE);
    VAL_LIMIT(chassis.leg_R.wheel_torque, MIN_WHEEL_TORQUE, MAX_WHEEL_TORQUE);

}

/* ============================= 4. 计算力矩 关节 ============================= */

static void joint_calc(void)
{

    /* ============================= 3.1 不同腿长下进行多项式拟合 ============================= */

    chassis_K_matrix_fitting(chassis.leg_L.vmc.forward_kinematics.fk_L0.L0, joint_K_L, joint_fitting_factor);
    chassis_K_matrix_fitting(chassis.leg_R.vmc.forward_kinematics.fk_L0.L0, joint_K_R, joint_fitting_factor);

    /* ============================= 3.2 加入目标输入 ============================= */

    chassis.leg_L.vmc.forward_kinematics.Fxy_set_point.E.Tp_set_point =  
        joint_K_L[0] * (chassis.leg_L.state_variable_feedback.theta - 0.0f)
        + joint_K_L[1] * (chassis.leg_L.state_variable_feedback.theta_dot - 0.0f)
        + joint_K_L[2] * (chassis.leg_L.state_variable_feedback.x - 0.0f)
        + joint_K_L[3] * (chassis.leg_L.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
        + joint_K_L[4] * (chassis.leg_L.state_variable_feedback.phi - 0.0f)
        + joint_K_L[5] * (chassis.leg_L.state_variable_feedback.phi_dot - 0.0f);

    chassis.leg_R.vmc.forward_kinematics.Fxy_set_point.E.Tp_set_point =  
        joint_K_R[0] * (chassis.leg_R.state_variable_feedback.theta - 0.0f)
        + joint_K_R[1] * (chassis.leg_R.state_variable_feedback.theta_dot - 0.0f)
        + joint_K_R[2] * (chassis.leg_R.state_variable_feedback.x - 0.0f)
        + joint_K_R[3] * (chassis.leg_R.state_variable_feedback.x_dot - chassis.chassis_ctrl_info.v_m_per_s)
        + joint_K_R[4] * (chassis.leg_R.state_variable_feedback.phi - 0.0f)
        + joint_K_R[5] * (chassis.leg_R.state_variable_feedback.phi_dot - 0.0f);

     /* =========================== 2. 正动力学变换 =========================== */

     vmc_forward_dynamics(&chassis.leg_L.vmc, &chassis_physical_config);
     vmc_forward_dynamics(&chassis.leg_R.vmc, &chassis_physical_config);

     /* =========================== 4.2 提取力矩 =========================== */

    chassis.leg_L.joint_F_torque = chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T1_set_point; // 左前
    chassis.leg_L.joint_B_torque = chassis.leg_L.vmc.forward_kinematics.T1_T4_set_point.E.T4_set_point; // 左后

    chassis.leg_R.joint_F_torque = chassis.leg_R.vmc.forward_kinematics.T1_T4_set_point.E.T1_set_point; // 右前
    chassis.leg_R.joint_B_torque = chassis.leg_R.vmc.forward_kinematics.T1_T4_set_point.E.T4_set_point; // 右后

    /* ============================= 限幅 ============================= */

    VAL_LIMIT(chassis.leg_R.joint_F_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
    VAL_LIMIT(chassis.leg_R.joint_B_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
    VAL_LIMIT(chassis.leg_L.joint_F_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);
    VAL_LIMIT(chassis.leg_L.joint_B_torque, MIN_JOINT_TORQUE, MAX_JOINT_TORQUE);

}

/* =========================== 底盘观测器更新 ====================== */

static void chassis_observer_update(void) 
{
    /* =========================== 获取传感器数据 ====================== */

    get_IMU_info();

    /* =========================== 1. 正解算 =========================== */

    vmc_calc();

    /* =========================== 更新底盘变量 ====================== */

    chassis_variable_update();

}

/* ============================= 底盘使能任务 ============================= */

static void chassis_enable_task(void) 
{
    /* ============================= 4. 计算力矩 轮毂 ============================= */

    wheel_calc();

    /* ============================= 4. 计算力矩 关节 ============================= */

    joint_calc();

    /* ============================= 倒地自救 ============================= */

    chassis_selfhelp();

}

/* =========================== 底盘任务 =========================== */

void chassis_task(void)
{

    /* =========================== 获取底盘遥控器信息 =========================== */

    chassis_remote_cmd();

    /* =========================== 底盘观测器更新 =========================== */

    chassis_observer_update();

    /* =========================== 使能任务 =========================== */

    chassis_enable_task();

    /* =========================== 发送力矩 =========================== */

    MIT_send_torque_task(-chassis.leg_L.joint_F_torque,
                         -chassis.leg_L.joint_B_torque,
                         chassis.leg_R.joint_F_torque,
                         chassis.leg_R.joint_B_torque,
                         chassis.leg_L.wheel_torque,
                         chassis.leg_R.wheel_torque,
                         0,
                         0,
                         0,
                         0);
}
```

## 定义如下图：

 ![](D:\A_EMBEDDED\RM\program\post\istics.github.io\Post\Picture\InvertedPendulum-LQR.png)

| 角度       | 含义         | 正方向 | 单位    |
| -------- | ---------- | --- | ----- |
| $\theta$ | 摆杆与竖直方向的夹角 | 顺时针 | $rad$ |
| $\phi$   | 机体与水平方向的夹角 | 逆时针 | $rad$ |

| 位移/距离 | 含义           | 正方向 | 单位  |
| ----- | ------------ | --- | --- |
| $x$   | 轮毂位移         | 向右  | $m$ |
| $x_p$ | 摆杆质心位移       | 向右  | $m$ |
| $x_M$ | 机体质心位移       | 向右  | $m$ |
| $B_L$ | 机体长度（x方向）    |     | $m$ |
| $B_H$ | 机体高度（z方向）    |     | $m$ |
| $L$   | 摆杆重心到轮毂轴线的距离 |     | $m$ |
| $L_M$ | 摆杆重心到机体转轴的距离 |     | $m$ |
| $l$   | 机体重心到机体转轴的距离 |     | $m$ |
| $R$   | 轮毂半径         |     | $m$ |

| 力/力矩  | 含义           | 正方向         | 单位    |
| ----- | ------------ | ----------- | ----- |
| $T$   | 轮毂电机的输出力矩    | 右手螺旋向内(顺时针) | $N·m$ |
| $T_p$ | 关节电机等效输出力矩   | 右手螺旋向内(顺时针) | $N·m$ |
| $N$   | 轮毂对摆杆的力的水平分量 | 向右          | $N$   |
| $P$   | 轮毂对摆杆的力的竖直分量 | 向上          | $N$   |
| $N_M$ | 摆杆对机体的力的水平分量 | 向右          | $N$   |
| $P_M$ | 摆杆对机体的力的竖直分量 | 向上          | $N$   |
| $N_f$ | 地面对轮毂的摩擦力    | 向右          | $N$   |

| 质量    | 含义                | 单位   |
| ----- | ----------------- | ---- |
| $m_w$ | 轮毂质量（不含轮毂电机）      | $kg$ |
| $m_p$ | 摆杆质量（含轮毂电机不含关节电机） | $kg$ |
| $M$   | 机体质量（含关节电机）       | $kg$ |

| 转动惯量  | 含义               | 单位       |
| ----- | ---------------- | -------- |
| $I_w$ | 轮毂转子的转动惯量        | $kg·m^2$ |
| $I_p$ | 摆杆绕质心的转动惯量       | $kg·m^2$ |
| $I_M$ | 机体绕质心的转动惯量($x$轴) | $kg·m^2$ |

## 1. 得到$A,B$

###### 1.1 <mark>机械给定$R,l,m_w,m_p,M,I_w,I_M,g,B_L,B_H$</mark>

###### 1.2 由上文得到的$L_0$，可得：

            $L_0=L+L_M$，<mark>此处理想化</mark>为$L=\frac{L_0}{2},L_M=\frac{L_0}{2}$

            $I_p=\frac{ m_p [(L + LM)^2 + 0.05 ^ 2]}{12}$

            $I_w,I_M$用$I_w=\frac{m_wR^2}{2},I_M=\frac{M(B_L^2+B_H)^2}{12}$计算也可以

###### 1.3 运动学分析

###### 1.3.1 对轮毂：

                牛顿第二定律：$m_w x''=N_f-N$……1.3.1.1

                转动定律：$I_w \frac{x''}{R}=T-N_fR$……1.3.1.2

###### 1.3.2 对摆杆：

                位移：

                    $x_p=x+Lsin\theta$

                    $y_p=Lcos\theta$

                加速度：

                    $x_p''=x''+L\theta''cos\theta-L\theta'^2sin\theta$

                    $y_p''=-L\theta''sin\theta-L\theta'^2cos\theta$

                牛顿第二定律：

                    $N-N_M=m_px_p''$……1.3.2.1

                    $P-P_M-m_pg=m_py_p''$……1.3.2.2

                转动定律：

                    $Ip \theta''=(PL+P_ML_M)sin\theta-(NL+N_ML_M)cos\theta-T+T_P$……1.3.2.3

###### 1.3.3 对机体：

                位移：

                    $x_M=x+(L+L_M)sin\theta-lsin\phi$

                    $y_M=(L+L_M)cos\theta+lcos\phi$

                加速度：

                    $x_M''=x''+(L+L_M)(\theta''cos\theta-\theta'^2sin\theta)-l(\phi''cos\phi-\phi'^2sin\phi)$

                    $y_M''=-(L+L_M)(\theta''sin\theta+\theta'^2cos\theta)-l(\phi''sin\phi-\phi'^2cos\phi)$

                牛顿第二定律：

                    $N_M=Mx_M''$……1.3.3.1

                    $P_M-Mg=M y_M''$……1.3.3.2

                转动定律：

                    $I_M\phi''=T_p+N_Mlcos\phi+P_Mlsin\phi$……1.3.3.3

###### 1.4 线性化：$sin\theta=\theta,cos\theta=1,sin\phi=\phi,cos\phi=1$，并忽略高阶项

            由1.3.2.1，可得：$N-N_M=m_p(x''+L\theta'')$……1.4.1

            由1.3.2.2，可得：$P=P_M-m_pg$……1.4.2

            由1.3.2.3，可得：$Ip \theta''=(PL+P_ML_M)\theta-NL-N_ML_M-T+T_P$……1.4.3

            由1.3.3.1，可得：$N_M=M[x''+(L+L_M)\theta''-l\phi'']$……1.4.4

            由1.3.3.2，可得：$P_M=Mg$……1.4.5

            由1.3.3.3，可得：$I_M\phi''=T_p+N_Ml+P_Ml\phi$……1.4.6

###### 1.5 消去$N,P,N_M,P_M$，得到最终方程

            由1.3.1.1&1.3.1.2，可得：$N=\frac{T}{R}-(\frac{I_w}{R^2}+M_w)X''$……1.5.1

            由1.4.2&1.4.3&1.4.4&1.4.5&1.5.1，可得：

            $[I_p+m_pL^2+M(L+L_M)^2]\theta''+[(m_p+M)L+ML_M]x''+[-Ml(L+L_M)]\phi''=[(m_p+M)gL+MgL_M]\theta-T+T_p$……1.5.2

            由1.4.1&1.4.4&1.5.1，可得：

            $[m_pLR+MR（L+L_M)]\theta''+[\frac{I_w}{R}+R(M_w+m_p+M)]x''+[-RMl]\phi''=T$……1.5.3

            由1.4.4&1.4.5&1.4.6，可得：

            $I_M\phi''=T_p+[x''+(L+L_M)\theta''-l\phi'']Ml+Mgl\phi$……1.5.4

###### 1.6 将1.5.2&1.5.3&1.5.4整理为矩阵，可得：

            $\begin{bmatrix}M_{11}&M_{12}&M_{13}\\ M_{21}&M_{22}&M_{23}\\M_{31}&M_{32}&M_{33} \end{bmatrix} \begin{bmatrix} \theta''\\ x'' \\ \phi''\end{bmatrix}=\begin{bmatrix}Z_{11}&0&-1&1\\ 0&0&1&0\\0&Z_{32}&0&1\end{bmatrix}\begin{bmatrix}\theta \\ \phi \\ T \\T_p \end{bmatrix}$……1.6.1

            其中

            $M_{11}=I_p+m_pL^2+M(L+L_M)^2,M_{12}=(m_p+M)L+ML_M,M_{13}=-Ml(L+L_M)$

            $M_{21}=m_pLR+MR（L+L_M),M_{22}=\frac{I_w}{R}+R(M_w+m_p+M),M_{23}=-RMl$

            $M_{31}=-Ml(L+L_M),M_{32}=-Ml,M_{33}=I_M+Ml^2$

            $Z_{11}=(m_p+M)gL+MgL_M,Z_{32}=Mgl$

###### 1.7 记$G=M^{-1}Z$,由1.6.1可得：

            $\begin{bmatrix} \theta''\\ x'' \\ \phi''\end{bmatrix}=\begin{bmatrix}G_{11}&G_{12}&G_{13}&G_{14}\\ G_{21}&G_{22}&G_{23}&G_{24}\\G_{31}&G_{32}&G_{33}&G_{34}\end{bmatrix}\begin{bmatrix}\theta \\ \phi \\ T \\T_p \end{bmatrix}$……1.7.1

###### 1.8 由1.7.1，可得：

            $\theta''=G_{11}\theta+G_{12}\phi+G_{13}T+G_{14}T_p$……1.8.1

            $x''=G_{21}\theta+G_{22}\phi+G_{23}T+G_{24}T_p$……1.8.2

            $\phi''=G_{31}\theta+G_{32}\phi+G_{33}T+G_{34}T_p$……1.8.3

            定义

            $X=\begin{bmatrix}\theta \\ \theta'\\x\\x'\\ \phi\\ \phi'\end{bmatrix},u=\begin{bmatrix}T \\T_p\end{bmatrix}$

            根据1.8.1&1.8.2&1.8.3，可得：

            $X'=\begin{bmatrix} \theta' \\ \theta'' \\ x'\\ x''\\ \phi'\\ \phi''\end{bmatrix}=\begin{bmatrix} \theta' \\ G_{11}\theta+G_{12}\phi+G_{13}T+G_{14}T_p \\ x'\\ G_{21}\theta+G_{22}\phi+G_{23}T+G_{24}T_p\\ \phi'\\ G_{31}\theta+G_{32}\phi+G_{33}T+G_{34}T_p\end{bmatrix}$

            根据$X'=AX+Bu$，可得：

            $A=\begin{bmatrix}0&1&0&0&0&0\\G_{11}&0&0&0&G_{12}&0\\0&0&0&1&0&0\\G_{21}&0&0&0&G_{22}&0\\0&0&0&0&0&1 \\G_{31}&0&0&0&G_{32}&0 \end{bmatrix},B=\begin{bmatrix}0&0\\G_{13}&G_{14}\\0&0\\G_{23}&G_{24}\\0&0\\G_{33}&G_{34}\end{bmatrix}$

## 2.  得到$K$

###### 2.1 <mark>根据实际情况，设定Q,R</mark>

            <mark>权重越大 能量消耗越小 收敛越快</mark>

            $Q = \begin{bmatrix}Q_{11}&0&0&0&0&0 \\ 0&Q_{22}&0&0&0&0&\\0&0&Q_{33}&0&0&0\\0&0&0&Q_{44}&0&0\\0&0&0&0&Q_{55}&0\\0&0&0&0&0&Q_{66}\end{bmatrix}$

            $Q$各项分别代表

            $\theta$的权重 $\theta'$的权重 $x$的权重 $x'$的权重 $\phi$的权重 $\phi'$的权重

            $R =\begin{bmatrix}R_{11}&0\\0&R_{22}\end{bmatrix}$

            $R$各项分别代表

            轮毂的权重 关节的权重

###### 2.2 <mark>根据控制频率设置dt</mark>，调用lqrd函数，求离散lqr

            $K = lqrd(A,B,Q,R,dt)$

            $K$各项分别代表 

            轮毂$\theta$的增益 轮毂$\theta'$的增益 轮毂$x$的增益 轮毂$x'$的增益 轮毂$\phi$的增益 轮毂$\phi'$的增益

            关节$\theta$的增益 关节$\theta'$的增益 关节$x$的增益 关节$x'$的增益 关节$\phi$的增益 关节$\phi'$的增益  

## 3. 优化$u$

###### 3.1 <mark>根据机械结构设定最小&最大腿长</mark>，在腿长区间内每10mm求一次K，并进行拟合

        $K_{ij}(L_0)=p_{0|ij}+p_{1|ij}L_0+p_{2|ij}L_0^2+p_{3|ij}L_0^3$

###### 3.2 为使机器人跟踪轨迹，还需在系统输入中加入目标输入，即：

            $u=-K(X_d-X)=-\begin{bmatrix}K_{11}&K_{12}&K_{13}&K_{14}&K_{15}&K_{16}\\K_{21}&K_{22}&K_{23}&K_{24}&K_{25}&K_{26}\end{bmatrix}(\begin{bmatrix}\theta_d \\ \theta_d' \\ x_d \\ x_d' \\ \phi_d\\ \phi_d' \end{bmatrix}-\begin{bmatrix}\theta \\ \theta' \\ x \\ x' \\ \phi\\ \phi' \end{bmatrix})=\begin{bmatrix}K_{11}&K_{12}&K_{13}&K_{14}&K_{15}&K_{16}\\K_{21}&K_{22}&K_{23}&K_{24}&K_{25}&K_{26}\end{bmatrix}(\begin{bmatrix}0 \\ 0 \\ 0 \\ x_d' \\ 0\\0\end{bmatrix}-\begin{bmatrix}\theta \\ \theta' \\ x \\ x' \\ \phi\\ \phi' \end{bmatrix})$

## 4. 计算力矩$\begin{bmatrix}T \\T_p\end{bmatrix}$

###### 4.1 计算力矩

            $u=K(L_0)(X_d-X)$

            根据$u=\begin{bmatrix}T \\T_p\end{bmatrix}$，可得：

            $T=-K_{11}\theta-K_{12}\theta''-K_{13}x+K_{14}(x_d'-x')-K_{15}\phi-K_{16}\phi'$

            $T_p=-K_{21}\theta-K_{22}\theta''-K_{23}x+K_{24}(x_d'-x')-K_{25}\phi-K_{26}\phi'$

###### 4.2 <mark>根据机械结构调整力矩</mark>

> 套用只需按实际情况改变高亮部分数据
